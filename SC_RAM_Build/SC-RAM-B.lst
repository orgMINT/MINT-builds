0000                             ; *************************************************************************
0000                             ; 
0000                             ;       MINT Minimal Interpreter for the Z80
0000                             ; 
0000                             ;       Ken Boak, John Hardy and Craig Jones.
0000                             ; 
0000                             ;       GNU GENERAL PUBLIC LICENSE                   Version 3, 29 June 2007
0000                             ; 
0000                             ;       see the LICENSE file in this repo for more information
0000                             ; 
0000                             ; *****************************************************************************
0000                             ; Southern Cross RAM build
0000                PGMSTART:   EQU   $2000   
0000                RAMSTART:   EQU   $3800   
0000                             ; SC I/O port addresses
0000                IO0:      EQU   80H   ;IO port 0
0000                IO1:      EQU   81H   ;IO port 1
0000                IO2:      EQU   82H   ;IO port 2
0000                IO3:      EQU   83H   ;IO port 3
0000                DISPLY:   EQU   84H   ;display latch
0000                SCAN:     EQU   85H   ;display scan latch
0000                KEYBUF:   EQU   86H   ;keyboard buffer
0000                IO7:      EQU   87H   ;toggle single stepper (if fitted)
2000                          .ORG   PGMSTART   
2000   21 A0 20               LD   HL,RxChar   
2003   22 7C 3A               LD   (GETCVEC),HL   
2006   21 75 20               LD   HL,TxChar   
2009   22 7E 3A               LD   (PUTCVEC),HL   
200C   CD 62 20               CALL   InitialiseSerial   
200F   C3 DA 20               JP   start   
2012                             ;SC hexadecimal to 7 segment display code table
2040                          .ORG   PGMSTART+$0040   
2040                SEVENSEGMENT:      
2040   3F 06 5B 4F            DB   3FH,06H,5BH,4FH   ;0,1,2,3
2044   66 6D 7D 07            DB   66H,6DH,7DH,07H   ;4,5,6,7
2048   7F 6F 77 7C            DB   7FH,6FH,77H,7CH   ;8,9,A,B
204C   39 5E 79 71            DB   39H,5EH,79H,71H   ;C,D,E,F
2050                             ; SC IO Port locations
2050                          .ORG   PGMSTART+$50   
2050   86                     DB   $86   ;KEYBUF
2051   85                     DB   $85   ;SCAN
2052   84                     DB   $84   ;DISPLY
2053   80                     DB   $80   ;IO0
2054   81                     DB   $81   ;IO1
2055   82                     DB   $82   ;IO2
2056   83                     DB   $83   ;IO3
2057   87                     DB   $87   ;IO7
2058                GETCHAR:      
2058   2A 7C 3A               LD   HL,(GETCVEC)   
205B   E9                     JP   (HL)   
205C                PUTCHAR:      
205C   E5                     PUSH   HL   
205D   2A 7E 3A               LD   HL,(PUTCVEC)   
2060   E3                     EX   (SP),HL   
2061   C9                     RET      
2062                             ;serial port
2062                             ; *************************************************************************
2062                             ; 
2062                             ;       MINT Minimal Interpreter for the Z80
2062                             ; 
2062                             ;       Ken Boak, John Hardy and Craig Jones.
2062                             ; 
2062                             ;       GNU GENERAL PUBLIC LICENSE                   Version 3, 29 June 2007
2062                             ; 
2062                             ;       see the LICENSE file in this repo for more information
2062                             ; 
2062                             ; *****************************************************************************
2062                             ;bit bang serial routines
2062                             ; bit bang baud rate constants @ 4MHz
2062                B300:     EQU   0220H   
2062                B1200:    EQU   0080H   
2062                B2400:    EQU   003FH   
2062                B4800:    EQU   001BH   
2062                B9600:    EQU   000BH   
2062                             ;initialise the bit bang serial port
2062                             ;-----------------------------------
2062                INITIALISESERIAL:      
2062   21 00 20               LD   HL,$2000   ;power up delay
2065   CD CD 20               CALL   bitime   
2068   3E 40                  LD   A,$40   
206A   0E 85                  LD   C,SCAN   
206C   ED 79                  OUT   (C),A   ;make the output port high
206E   21 1B 00               LD   HL,B4800   
2071   22 76 3A               LD   (BAUD),HL   ;set up the baud rate
2074   C9                     RET      
2075                             ; bit bang serial transmit routine
2075                             ;---------------------------------
2075                             ; transmit a byte via an output port pin
2075                             ; entry : A = byte to transmit
2075                             ;  exit : no registers modified
2075                TXCHAR:      
2075   F5                     PUSH   AF   
2076   C5                     PUSH   BC   
2077   E5                     PUSH   HL   
2078   2A 76 3A               LD   HL,(BAUD)   ;HL holds the bit time delay
207B   4F                     LD   C,A   
207C                             ;transmit the start bit
207C   AF                     XOR   A   
207D   D3 85                  OUT   (SCAN),A   
207F   CD CD 20               CALL   bitime   
2082                             ; transmit 8 bits of data
2082   06 08                  LD   B,08H   
2084   CB 09                  RRC   C   
2086                NXTBIT:      
2086   CB 09                  RRC   C   ;shift bits to D6
2088   79                     LD   A,C   ;send lsb first
2089   E6 40                  AND   $40   ;for one bit time
208B   D3 85                  OUT   (SCAN),A   
208D   CD CD 20               CALL   bitime   
2090   10 F4                  DJNZ   nxtbit   
2092                             ;send the stop bits
2092   3E 40                  LD   A,40H   
2094   D3 85                  OUT   (SCAN),A   
2096   CD CD 20               CALL   bitime   
2099   CD CD 20               CALL   bitime   
209C   E1                     POP   HL   
209D   C1                     POP   BC   
209E   F1                     POP   AF   
209F   C9                     RET      
20A0                             ; bit bang serial receive routine
20A0                             ;--------------------------------
20A0                             ;receive a byte via an input port pin
20A0                             ; entry : none
20A0                             ; exit : A = received byte if carry clear
20A0                             ; AF registers modified
20A0                RXCHAR:      
20A0   C5                     PUSH   BC   
20A1   E5                     PUSH   HL   
20A2                             ;wait for the start bit high to low transition
20A2                STARTBIT:      
20A2   DB 86                  IN   A,(KEYBUF)   
20A4   CB 7F                  BIT   7,A   
20A6   20 FA                  JR   NZ,startbit   ;no start bit yet
20A8                             ; start bit detected
20A8   2A 76 3A               LD   HL,(BAUD)   ;delay for half a
20AB   CB 3C                  SRL   H   ;bit time to sample the middle
20AD   CB 1D                  RR   L   ;of the bit cell
20AF   CD CD 20               CALL   bitime   
20B2   DB 86                  IN   A,(KEYBUF)   
20B4   CB 7F                  BIT   7,A   ;check the start bit is still low
20B6   20 EA                  JR   NZ,startbit   
20B8                             ; valid start bit detected
20B8   06 08                  LD   B,$08   
20BA                GETBITS:      
20BA   2A 76 3A               LD   HL,(BAUD)   
20BD   CD CD 20               CALL   bitime   ;delay one full bit time
20C0   DB 86                  IN   A,(KEYBUF)   
20C2   CB 17                  RL   A   
20C4   CB 19                  RR   C   ;shift bit into output reg
20C6   10 F2                  DJNZ   getbits   
20C8   79                     LD   A,C   
20C9   B7                     OR   A   ;clear carry flag
20CA   E1                     POP   HL   
20CB   C1                     POP   BC   
20CC   C9                     RET      
20CD                             ; bit time delay
20CD                             ;---------------
20CD                             ;delay for one serial bit time
20CD                             ;entry : HL = delay time
20CD                             ;no registers modified
20CD                BITIME:      
20CD   E5                     PUSH   HL   
20CE   D5                     PUSH   DE   
20CF   11 01 00               LD   DE,0001H   
20D2                BITIM1:      
20D2   ED 52                  SBC   HL,DE   
20D4   D2 D2 20               JP   NC,bitim1   
20D7   D1                     POP   DE   
20D8   E1                     POP   HL   
20D9   C9                     RET      
20DA                             ;.include "Char-6850.asm"
20DA                             ;.include "RC2014-6850.asm"
20DA                             ;Intel Hex File Load
20DA                             ;.include "IntelHexLoader.asm"
20DA                             ;MINT
20DA                             ; *************************************************************************
20DA                             ; 
20DA                             ;       MINT Minimal Interpreter for the Z80
20DA                             ; 
20DA                             ;       Ken Boak, John Hardy and Craig Jones.
20DA                             ; 
20DA                             ;       GNU GENERAL PUBLIC LICENSE                   Version 3, 29 June 2007
20DA                             ; 
20DA                             ;       see the LICENSE file in this repo for more information
20DA                             ; 
20DA                             ; *****************************************************************************
20DA                             ;ROMSTART    EQU $0
20DA                             ;RAMSTART    EQU $800
20DA                             ;EXTENDED    EQU 0
20DA                             ;ROMSIZE     EQU $800
20DA                DSIZE:    EQU   $80   
20DA                RSIZE:    EQU   $80   
20DA                TIBSIZE:   EQU   $100   
20DA                TRUE:     EQU   1   
20DA                FALSE:    EQU   0   
20DA                NUMGRPS:   EQU   5   
20DA                GRPSIZE:   EQU   $40   
20DA                             ; **************************************************************************
20DA                             ; Page 0  Initialisation
20DA                             ; **************************************************************************		
20DA                             ;		.ORG ROMSTART + $180		
20DA                START:       
20DA                MINT:        
20DA   31 80 38               LD   SP,DSTACK   
20DD   CD 04 21               CALL   initialize   
20E0   CD C8 21               CALL   ENTER   
20E3   60 4D 49 4E 54 20 56 31 2E 30 60 5C 4E 00 .CSTR   "`MINT V1.0`\\N"   
20F1   C3 3E 21               JP   interpret   
20F4                             ; ***********************************************************************
20F4                             ; Initial values for user mintVars		
20F4                             ; ***********************************************************************		
20F4                ISYSVARS:      
20F4   80 38                  DW   dStack   ; a vS0
20F6   00 00                  DW   FALSE   ; b vBase16
20F8   00 00                  DW   0   ; c vTIBPtr
20FA   C0 3A                  DW   DEFS   ; d vDEFS
20FC   00 00                  DW   0   ; e vEdited the last command to be edited
20FE   00 00                  DW   0   ; f
2100   00 00                  DW   0   ; g
2102   00 3C                  DW   HEAP   ; h vHeapPtr
2104                INITIALIZE:      
2104   DD 21 00 39            LD   IX,RSTACK   
2108   FD 21 A4 21            LD   IY,NEXT   ; IY provides a faster jump to NEXT
210C   21 F4 20               LD   HL,iSysVars   
210F   11 00 3A               LD   DE,sysVars   
2112   01 10 00               LD   BC,8 * 2   
2115   ED B0                  LDIR      
2117   21 C0 3A               LD   HL,DEFS   
211A   06 A0                  LD   B,GRPSIZE/2 * NUMGRPS   
211C                INIT1:       
211C   36 F0                  LD   (HL),lsb(empty_)   
211E   23                     INC   HL   
211F   36 21                  LD   (HL),msb(empty_)   
2121   23                     INC   HL   
2122   10 F8                  DJNZ   init1   
2124   C9                     RET      
2125                MACRO:       ; 25
2125   ED 43 04 3A            LD   (vTIBPtr),BC   
2129   21 80 23               LD   HL,ctrlCodes   
212C   85                     ADD   A,L   
212D   6F                     LD   L,A   
212E   5E                     LD   E,(HL)   
212F   16 21                  LD   D,msb(macros)   
2131   D5                     PUSH   DE   
2132   CD C8 21               CALL   ENTER   
2135   5C 47 00               .CSTR   "\\G"   
2138   ED 4B 04 3A            LD   BC,(vTIBPtr)   
213C   18 11                  JR   interpret2   
213E                INTERPRET:      
213E   CD C8 21               CALL   ENTER   
2141   5C 4E 60 3E 20 60 00   .CSTR   "\\N`> `"   
2148                INTERPRET1:      ; used by tests
2148   01 00 00               LD   BC,0   ; load BC with offset into TIB
214B   ED 43 04 3A            LD   (vTIBPtr),BC   
214F                INTERPRET2:      ; calc nesting (a macro might have changed it)
214F   1E 00                  LD   E,0   ; initilize nesting value
2151   C5                     PUSH   BC   ; save offset into TIB,
2152                             ; BC is also the count of chars in TIB
2152   21 00 39               LD   HL,TIB   ; HL is start of TIB
2155   18 06                  JR   interpret4   
2157                INTERPRET3:      
2157   7E                     LD   A,(HL)   ; A = char in TIB
2158   23                     INC   HL   ; inc pointer into TIB
2159   0B                     DEC   BC   ; dec count of chars in TIB
215A   CD A4 27               CALL   nesting   ; update nesting value
215D                INTERPRET4:      
215D   79                     LD   A,C   ; is count zero?
215E   B0                     OR   B   
215F   20 F6                  JR   NZ,interpret3   ; if not loop
2161   C1                     POP   BC   ; restore offset into TIB
2162                             ; *******************************************************************
2162                             ; Wait for a character from the serial input (keyboard)
2162                             ; and store it in the text buffer. Keep accepting characters,
2162                             ; increasing the instruction pointer BC - until a newline received.
2162                             ; *******************************************************************
2162                WAITCHAR:      
2162   CD 58 20               CALL   getchar   ; loop around waiting for character
2165   FE 20                  CP   $20   
2167   30 0C                  JR   NC,waitchar1   
2169   FE 00                  CP   $0   ; is it end of string?
216B   28 2C                  JR   Z,waitchar4   
216D   FE 0D                  CP   "\r"   ; carriage return?
216F   28 12                  JR   Z,waitchar3   
2171   16 00                  LD   D,0   
2173   18 B0                  JR   macro   
2175                WAITCHAR1:      
2175   21 00 39               LD   HL,TIB   
2178   09                     ADD   HL,BC   
2179   77                     LD   (HL),A   ; store the character in textbuf
217A   03                     INC   BC   
217B   CD 5C 20               CALL   putchar   ; echo character to screen
217E   CD A4 27               CALL   nesting   
2181   18 DF                  JR   waitchar   ; wait for next character
2183                WAITCHAR3:      
2183   21 00 39               LD   HL,TIB   
2186   09                     ADD   HL,BC   
2187   36 0D                  LD   (HL),"\r"   ; store the crlf in textbuf
2189   23                     INC   HL   
218A   36 0A                  LD   (HL),"\n"   
218C   23                     INC   HL   ; ????
218D   03                     INC   BC   
218E   03                     INC   BC   
218F   CD D0 27               CALL   crlf   ; echo character to screen
2192   7B                     LD   A,E   ; if zero nesting append and ETX after \r
2193   B7                     OR   A   
2194   20 CC                  JR   NZ,waitchar   
2196   36 03                  LD   (HL),$03   ; store end of text ETX in text buffer
2198   03                     INC   BC   
2199                WAITCHAR4:      
2199   ED 43 04 3A            LD   (vTIBPtr),BC   
219D   01 00 39               LD   BC,TIB   ; Instructions stored on heap at address HERE
21A0   0B                     DEC   BC   
21A1   C3 A4 21               JP   NEXT   
21A4                             ; ********************************************************************************
21A4                             ; 
21A4                             ; Dispatch Routine.
21A4                             ; 
21A4                             ; Get the next character and form a 1 byte jump address
21A4                             ; 
21A4                             ; This target jump address is loaded into HL, and using JP (HL) to quickly
21A4                             ; jump to the selected function.
21A4                             ; 
21A4                             ; Individual handler routines will deal with each category:
21A4                             ; 
21A4                             ; 1. Detect characters A-Z and jump to the User Command handler routine
21A4                             ; 
21A4                             ; 2. Detect characters a-z and jump to the variable handler routine
21A4                             ; 
21A4                             ; 3. All other characters are punctuation and cause a jump to the associated
21A4                             ; primitive code.
21A4                             ; 
21A4                             ; Instruction Pointer IP BC is incremented
21A4                             ; 
21A4                             ; *********************************************************************************
21A4                NEXT:        ; 9
21A4   03                     INC   BC   ; 6t    Increment the IP
21A5   0A                     LD   A,(BC)   ; 7t    Get the next character and dispatch
21A6   6F                     LD   L,A   ; 4t    Index into table
21A7   26 23                  LD   H,msb(opcodes)   ; 7t    Start address of jump table
21A9   6E                     LD   L,(HL)   ; 7t    get low jump address
21AA   26 24                  LD   H,msb(page4)   ; 7t    Load H with the 1st page address
21AC   E9                     JP   (HL)   ; 4t    Jump to routine
21AD                             ; ARRAY compilation routine
21AD                COMPNEXT:      ; 20
21AD   D1                     POP   DE   ; DE = return address
21AE   2A 0E 3A               LD   HL,(vHeapPtr)   ; load heap ptr
21B1   73                     LD   (HL),E   ; store lsb
21B2   3A 36 3A               LD   A,(vByteMode)   
21B5   23                     INC   HL   
21B6   B7                     OR   A   
21B7   20 02                  JR   NZ,compNext1   
21B9   72                     LD   (HL),D   
21BA   23                     INC   HL   
21BB                COMPNEXT1:      
21BB   22 0E 3A               LD   (vHeapPtr),HL   ; save heap ptr
21BE   18 E4                  JR   NEXT   
21C0                GETREF:      ;= 8
21C0   03                     INC   BC   
21C1   0A                     LD   A,(BC)   
21C2   CD 56 27               CALL   getGroup   
21C5   C3 6B 24               JP   fetch1   
21C8                ENTER:       ; 9
21C8   60 69                  LD   HL,BC   
21CA   CD E2 27               CALL   rpush   ; save Instruction Pointer
21CD   C1                     POP   BC   
21CE   0B                     DEC   BC   
21CF   FD E9                  JP   (IY)   ; Execute code from User def
21D1                             ; Print an 8-bit HEX number  - shortened KB 25/11/21
21D1                             ; A: Number to print
21D1                PRINT_HEX8:      ;= 20
21D1   4F                     LD   C,A   
21D2   1F                     RRA      
21D3   1F                     RRA      
21D4   1F                     RRA      
21D5   1F                     RRA      
21D6   CD DA 21               CALL   conv   
21D9   79                     LD   A,C   
21DA                CONV:        
21DA   E6 0F                  AND   0x0F   
21DC   C6 90                  ADD   A,0x90   
21DE   27                     DAA      
21DF   CE 40                  ADC   A,0x40   
21E1   27                     DAA      
21E2   C3 5C 20               JP   putchar   
21E5                PRINTHEX:      ;= 11
21E5                             ; Display HL as a 16-bit number in hex.
21E5   C5                     PUSH   BC   ; preserve the IP
21E6   7C                     LD   A,H   
21E7   CD D1 21               CALL   Print_Hex8   
21EA   7D                     LD   A,L   
21EB   CD D1 21               CALL   Print_Hex8   
21EE   C1                     POP   BC   
21EF   C9                     RET      
21F0                             ; **************************************************************************
21F0                             ; Macros must be written in Mint and end with ;
21F0                             ; this code must not span pages
21F0                             ; **************************************************************************
21F0                MACROS:      
21F0                EMPTY_:      
21F0   3B                     DB   ";"   
21F1                BACKSP_:      
21F1   5C 63 40 30 3D 30 3D 28 31 5F 5C 63 5C 2B 60 08 20 08 60 29 3B DB   "\\c@0=0=(1_\\c\\+`\b \b`);"   
2206                REEDIT_:      
2206   5C 65 5C 40 5C 5A 3B   DB   "\\e\\@\\Z;"   
220D                EDIT_:       
220D   60 3F 60 5C 4B 5C 4E 60 3E 20 60 5C 5E 41 2D 5C 5A 3B 00 .CSTR   "`?`\\K\\N`> `\\^A-\\Z;"   
2220                LIST_:       
2220   5C 4E 32 36 28 5C 69 40 5C 5A 5C 63 40 30 3E 28 5C 4E 29 29 5C 4E 60 3E 20 60 3B 00 .CSTR   "\\N26(\\i@\\Z\\c@0>(\\N))\\N`> `;"   
223C                PRINTSTACK_:      
223C   60 3D 3E 20 60 5C 50 5C 4E 5C 4E 60 3E 20 60 3B 00 .CSTR   "`=> `\\P\\N\\N`> `;"   
224D                TOGGLEBASE_:      
224D   5C 62 40 30 3D 5C 62 21 3B 00 .CSTR   "\\b@0=\\b!;"   
2257                             ; **************************************************************************
2257                             ; Page 2  Jump Tables
2257                             ; **************************************************************************
2257                          ALIGN   $100   
2300                OPCODES:      
2300                             ; ***********************************************************************
2300                             ; Initial values for user mintVars		
2300                             ; ***********************************************************************		
2300   60                     DB   lsb(exit_)   ;   NUL
2301   74                     DB   lsb(nop_)   ;   SOH
2302   74                     DB   lsb(nop_)   ;   STX
2303   5D                     DB   lsb(etx_)   ;   ETX
2304   74                     DB   lsb(nop_)   ;   EOT
2305   74                     DB   lsb(nop_)   ;   ENQ
2306   74                     DB   lsb(nop_)   ;   ACK
2307   74                     DB   lsb(nop_)   ;   BEL
2308   74                     DB   lsb(nop_)   ;   BS
2309   74                     DB   lsb(nop_)   ;   TAB
230A   74                     DB   lsb(nop_)   ;   LF
230B   74                     DB   lsb(nop_)   ;   VT
230C   74                     DB   lsb(nop_)   ;   FF
230D   74                     DB   lsb(nop_)   ;   CR
230E   74                     DB   lsb(nop_)   ;   SO
230F   74                     DB   lsb(nop_)   ;   SI
2310   74                     DB   lsb(nop_)   ;   DLE
2311   74                     DB   lsb(nop_)   ;   DC1
2312   74                     DB   lsb(nop_)   ;   DC2
2313   74                     DB   lsb(nop_)   ;   DC3
2314   74                     DB   lsb(nop_)   ;   DC4
2315   74                     DB   lsb(nop_)   ;   NAK
2316   74                     DB   lsb(nop_)   ;   SYN
2317   74                     DB   lsb(nop_)   ;   ETB
2318   74                     DB   lsb(nop_)   ;   CAN
2319   74                     DB   lsb(nop_)   ;   EM
231A   74                     DB   lsb(nop_)   ;   SUB
231B   74                     DB   lsb(nop_)   ;   ESC
231C   74                     DB   lsb(nop_)   ;   FS
231D   74                     DB   lsb(nop_)   ;   GS
231E   74                     DB   lsb(nop_)   ;   RS
231F   74                     DB   lsb(nop_)   ;   US
2320   74                     DB   lsb(nop_)   ;   SP
2321   88                     DB   lsb(store_)   ;   !
2322   58                     DB   lsb(dup_)   ;   "
2323   71                     DB   lsb(hex_)   ;    #
2324   8F                     DB   lsb(swap_)   ;    $
2325   7A                     DB   lsb(over_)   ;    %
2326   03                     DB   lsb(and_)   ;    &
2327   55                     DB   lsb(drop_)   ;    '
2328   31                     DB   lsb(begin_)   ;    (
2329   E1                     DB   lsb(again_)   ;    )
232A   DF                     DB   lsb(mul_)   ;    *
232B   25                     DB   lsb(add_)   ;    +
232C   46                     DB   lsb(hdot_)   ;    ,
232D   A7                     DB   lsb(sub_)   ;    -
232E   4C                     DB   lsb(dot_)   ;    .
232F   DD                     DB   lsb(div_)   ;    /
2330   77                     DB   lsb(num_)   ;    0
2331   77                     DB   lsb(num_)   ;    1
2332   77                     DB   lsb(num_)   ;    2
2333   77                     DB   lsb(num_)   ;    3
2334   77                     DB   lsb(num_)   ;    4
2335   77                     DB   lsb(num_)   ;    5
2336   77                     DB   lsb(num_)   ;    6
2337   77                     DB   lsb(num_)   ;    7
2338   77                     DB   lsb(num_)   ;    8
2339   77                     DB   lsb(num_)   ;    9
233A   43                     DB   lsb(def_)   ;    :
233B   81                     DB   lsb(ret_)   ;    ;
233C   C2                     DB   lsb(lt_)   ;    <
233D   AF                     DB   lsb(eq_)   ;    =
233E   BE                     DB   lsb(gt_)   ;    >
233F   BB                     DB   lsb(getRef_)   ;    ?
2340   6A                     DB   lsb(fetch_)   ;    @
2341   34                     DB   lsb(call_)   ;    A
2342   34                     DB   lsb(call_)   ;    B
2343   34                     DB   lsb(call_)   ;    C
2344   34                     DB   lsb(call_)   ;    D
2345   34                     DB   lsb(call_)   ;    E
2346   34                     DB   lsb(call_)   ;    F
2347   34                     DB   lsb(call_)   ;    G
2348   34                     DB   lsb(call_)   ;    H
2349   34                     DB   lsb(call_)   ;    I
234A   34                     DB   lsb(call_)   ;    J
234B   34                     DB   lsb(call_)   ;    K
234C   34                     DB   lsb(call_)   ;    L
234D   34                     DB   lsb(call_)   ;    M
234E   34                     DB   lsb(call_)   ;    N
234F   34                     DB   lsb(call_)   ;    O
2350   34                     DB   lsb(call_)   ;    P
2351   34                     DB   lsb(call_)   ;    Q
2352   34                     DB   lsb(call_)   ;    R
2353   34                     DB   lsb(call_)   ;    S
2354   34                     DB   lsb(call_)   ;    T
2355   34                     DB   lsb(call_)   ;    U
2356   34                     DB   lsb(call_)   ;    V
2357   34                     DB   lsb(call_)   ;    W
2358   34                     DB   lsb(call_)   ;    X
2359   34                     DB   lsb(call_)   ;    Y
235A   34                     DB   lsb(call_)   ;    Z
235B   2B                     DB   lsb(arrDef_)   ;    [
235C   00                     DB   lsb(alt_)   ;    \
235D   2E                     DB   lsb(arrEnd_)   ;    ]
235E   17                     DB   lsb(xor_)   ;    ^
235F   A1                     DB   lsb(neg_)   ;    _
2360   E4                     DB   lsb(str_)   ;    `
2361   D3                     DB   lsb(var_)   ;    a
2362   D3                     DB   lsb(var_)   ;    b
2363   D3                     DB   lsb(var_)   ;    c
2364   D3                     DB   lsb(var_)   ;    d
2365   D3                     DB   lsb(var_)   ;    e
2366   D3                     DB   lsb(var_)   ;    f
2367   D3                     DB   lsb(var_)   ;    g
2368   D3                     DB   lsb(var_)   ;    h
2369   D3                     DB   lsb(var_)   ;    i
236A   D3                     DB   lsb(var_)   ;    j
236B   D3                     DB   lsb(var_)   ;    k
236C   D3                     DB   lsb(var_)   ;    l
236D   D3                     DB   lsb(var_)   ;    m
236E   D3                     DB   lsb(var_)   ;    n
236F   D3                     DB   lsb(var_)   ;    o
2370   D3                     DB   lsb(var_)   ;    p
2371   D3                     DB   lsb(var_)   ;    q
2372   D3                     DB   lsb(var_)   ;    r
2373   D3                     DB   lsb(var_)   ;    s
2374   D3                     DB   lsb(var_)   ;    t
2375   D3                     DB   lsb(var_)   ;    u
2376   D3                     DB   lsb(var_)   ;    v
2377   D3                     DB   lsb(var_)   ;    w
2378   D3                     DB   lsb(var_)   ;    x
2379   D3                     DB   lsb(var_)   ;    y
237A   D3                     DB   lsb(var_)   ;    z
237B   94                     DB   lsb(shl_)   ;    {
237C   0E                     DB   lsb(or_)   ;    |
237D   99                     DB   lsb(shr_)   ;    }
237E   20                     DB   lsb(inv_)   ;    ~
237F   74                     DB   lsb(nop_)   ;    backspace
2380                             ; ***********************************************************************
2380                             ; Alternate function codes		
2380                             ; ***********************************************************************		
2380                CTRLCODES:      
2380                ALTCODES:      
2380   F0                     DB   lsb(empty_)   ; NUL ^@
2381   F0                     DB   lsb(empty_)   ; SOH ^A
2382   4D                     DB   lsb(toggleBase_)   ; STX ^B
2383   F0                     DB   lsb(empty_)   ; ETX ^C
2384   F0                     DB   lsb(empty_)   ; EOT ^D
2385   0D                     DB   lsb(edit_)   ; ENQ ^E
2386   F0                     DB   lsb(empty_)   ; ACK ^F
2387   F0                     DB   lsb(empty_)   ; BEL ^G
2388   F1                     DB   lsb(backsp_)   ; BS  ^H
2389   F0                     DB   lsb(empty_)   ; TAB ^I
238A   06                     DB   lsb(reedit_)   ; LF  ^J
238B   F0                     DB   lsb(empty_)   ; VT  ^K
238C   20                     DB   lsb(list_)   ; FF  ^L
238D   F0                     DB   lsb(empty_)   ; CR  ^M
238E   F0                     DB   lsb(empty_)   ; SO  ^N
238F   F0                     DB   lsb(empty_)   ; SI  ^O
2390   3C                     DB   lsb(printStack_)   ; DLE ^P
2391   F0                     DB   lsb(empty_)   ; DC1 ^Q
2392   F0                     DB   lsb(empty_)   ; DC2 ^R
2393   F0                     DB   lsb(empty_)   ; DC3 ^S
2394   F0                     DB   lsb(empty_)   ; DC4 ^T
2395   F0                     DB   lsb(empty_)   ; NAK ^U
2396   F0                     DB   lsb(empty_)   ; SYN ^V
2397   F0                     DB   lsb(empty_)   ; ETB ^W
2398   F0                     DB   lsb(empty_)   ; CAN ^X
2399   F0                     DB   lsb(empty_)   ; EM  ^Y
239A   F0                     DB   lsb(empty_)   ; SUB ^Z
239B   F0                     DB   lsb(empty_)   ; ESC ^[
239C   F0                     DB   lsb(empty_)   ; FS  ^\
239D   F0                     DB   lsb(empty_)   ; GS  ^]
239E   F0                     DB   lsb(empty_)   ; RS  ^^
239F   F0                     DB   lsb(empty_)   ; US  ^_)
23A0   0A                     DB   lsb(aNop_)   ; SP  ^`
23A1   1D                     DB   lsb(cStore_)   ;    !
23A2   0A                     DB   lsb(aNop_)   ;    "
23A3   0A                     DB   lsb(aNop_)   ;    #
23A4   0A                     DB   lsb(aNop_)   ;    $  ( -- adr ) text input ptr
23A5   0A                     DB   lsb(aNop_)   ;    %
23A6   0A                     DB   lsb(aNop_)   ;    &
23A7   0A                     DB   lsb(aNop_)   ;    '
23A8   3D                     DB   lsb(ifte_)   ;    (  ( b -- )
23A9   0A                     DB   lsb(aNop_)   ;    )
23AA   0A                     DB   lsb(aNop_)   ;    *
23AB   92                     DB   lsb(incr_)   ;    +  ( adr -- ) decrements variable at address
23AC   0A                     DB   lsb(aNop_)   ;    ,
23AD   0A                     DB   lsb(aNop_)   ;    -
23AE   0A                     DB   lsb(aNop_)   ;    .
23AF   0A                     DB   lsb(aNop_)   ;    /
23B0   0A                     DB   lsb(aNop_)   ;    0
23B1   0A                     DB   lsb(aNop_)   ;    1
23B2   0A                     DB   lsb(aNop_)   ;    2
23B3   0A                     DB   lsb(aNop_)   ;    3
23B4   0A                     DB   lsb(aNop_)   ;    4
23B5   0A                     DB   lsb(aNop_)   ;    5
23B6   0A                     DB   lsb(aNop_)   ;    6
23B7   0A                     DB   lsb(aNop_)   ;    7
23B8   0A                     DB   lsb(aNop_)   ;    8
23B9   0A                     DB   lsb(aNop_)   ;    9
23BA   0A                     DB   lsb(aNop_)   ;    :  start defining a macro
23BB   0A                     DB   lsb(aNop_)   ;    ;
23BC   0A                     DB   lsb(aNop_)   ;    <
23BD   0A                     DB   lsb(aNop_)   ;    =
23BE   0A                     DB   lsb(aNop_)   ;    >
23BF   0A                     DB   lsb(aNop_)   ;    ?
23C0   05                     DB   lsb(cFetch_)   ;    @
23C1   0A                     DB   lsb(aNop_)   ;    A
23C2   D0                     DB   lsb(break_)   ;    B
23C3   74                     DB   lsb(nop_)   ;    C
23C4   22                     DB   lsb(depth_)   ;    D  ( -- val ) depth of data stack
23C5   36                     DB   lsb(emit_)   ;    E   ( val -- ) emits a char to output
23C6   0A                     DB   lsb(aNop_)   ;    F
23C7   58                     DB   lsb(go_)   ;    G   ( -- ? ) execute mint definition
23C8   0A                     DB   lsb(aNop_)   ;    H
23C9   9D                     DB   lsb(inPort_)   ;    I  ( port -- val )
23CA   0A                     DB   lsb(aNop_)   ;    J
23CB   B2                     DB   lsb(key_)   ;    K  ( -- val )  read a char from input
23CC   0A                     DB   lsb(aNop_)   ;    L
23CD   0A                     DB   lsb(aNop_)   ;    M
23CE   BB                     DB   lsb(newln_)   ;    N   ; prints a newline to output
23CF   C0                     DB   lsb(outPort_)   ;    O  ( val port -- )
23D0   DF                     DB   lsb(printStk_)   ;    P  ( -- ) non-destructively prints stack
23D1   0A                     DB   lsb(aNop_)   ;    Q  quits from Mint REPL
23D2   C9                     DB   lsb(rot_)   ;    R  ( a b c -- b c a )
23D3   0A                     DB   lsb(aNop_)   ;    S
23D4   0A                     DB   lsb(aNop_)   ;    T
23D5   0A                     DB   lsb(aNop_)   ;    U
23D6   0A                     DB   lsb(aNop_)   ;    V
23D7   0A                     DB   lsb(aNop_)   ;    W   ; ( b -- ) if false, skip to end of loop
23D8   50                     DB   lsb(exec_)   ;    X
23D9   0A                     DB   lsb(aNop_)   ;    Y
23DA   E1                     DB   lsb(editDef_)   ;    Z
23DB   00                     DB   lsb(cArrDef_)   ;    [
23DC   14                     DB   lsb(comment_)   ;    \  comment text, skips reading until end of line
23DD   0A                     DB   lsb(aNop_)   ;    ]
23DE   0C                     DB   lsb(charCode_)   ;    ^
23DF   0A                     DB   lsb(aNop_)   ;    _
23E0   0A                     DB   lsb(aNop_)   ;    `
23E1   84                     DB   lsb(sysVar_)   ;    a  ; start of data stack variable
23E2   84                     DB   lsb(sysVar_)   ;    b  ; base16 variable
23E3   84                     DB   lsb(sysVar_)   ;    c  ; TIBPtr variable
23E4   84                     DB   lsb(sysVar_)   ;    d
23E5   84                     DB   lsb(sysVar_)   ;    e
23E6   84                     DB   lsb(sysVar_)   ;    f
23E7   84                     DB   lsb(sysVar_)   ;    g
23E8   84                     DB   lsb(sysVar_)   ;    h  ; heap ptr variable
23E9   8E                     DB   lsb(i_)   ;    i  ; returns index variable of current loop
23EA   A8                     DB   lsb(j_)   ;    j  ; returns index variable of outer loop
23EB   84                     DB   lsb(sysVar_)   ;    k
23EC   84                     DB   lsb(sysVar_)   ;    l
23ED   84                     DB   lsb(sysVar_)   ;    m  ( a b -- c ) return the minimum value
23EE   84                     DB   lsb(sysVar_)   ;    n
23EF   84                     DB   lsb(sysVar_)   ;    o
23F0   84                     DB   lsb(sysVar_)   ;    p
23F1   84                     DB   lsb(sysVar_)   ;    q
23F2   84                     DB   lsb(sysVar_)   ;    r
23F3   84                     DB   lsb(sysVar_)   ;    s
23F4   84                     DB   lsb(sysVar_)   ;    t
23F5   84                     DB   lsb(sysVar_)   ;    u
23F6   84                     DB   lsb(sysVar_)   ;    v
23F7   84                     DB   lsb(sysVar_)   ;    w
23F8   84                     DB   lsb(sysVar_)   ;    x
23F9   84                     DB   lsb(sysVar_)   ;    y
23FA   84                     DB   lsb(sysVar_)   ;    z
23FB   69                     DB   lsb(group_)   ;    {
23FC   0A                     DB   lsb(aNop_)   ;    |
23FD   61                     DB   lsb(endGroup_)   ;    }
23FE   0A                     DB   lsb(aNop_)   ;    ~
23FF   0A                     DB   lsb(aNop_)   ;    BS		
2400                             ; **********************************************************************			
2400                             ; Page 4 primitive routines
2400                             ; **********************************************************************
2400                          ALIGN   $100   
2400                PAGE4:       
2400                ALT_:        
2400   C3 F3 24               JP   alt   
2403                AND_:        
2403   D1                     POP   DE   ; 10t Bitwise AND the top 2 elements of the stack
2404   E1                     POP   HL   ; 10t
2405   7B                     LD   A,E   ; 4t
2406   A5                     AND   L   ; 4t
2407   6F                     LD   L,A   ; 4t
2408   7A                     LD   A,D   ; 4t
2409   A4                     AND   H   ; 4t
240A                AND1:        
240A   67                     LD   H,A   ; 4t
240B   E5                     PUSH   HL   ; 11t
240C   FD E9                  JP   (IY)   ; 8t
240E                             ; 63t
240E                OR_:         
240E   D1                     POP   DE   ; Bitwise OR the top 2 elements of the stack
240F   E1                     POP   HL   
2410   7B                     LD   A,E   
2411   B5                     OR   L   
2412   6F                     LD   L,A   
2413   7A                     LD   A,D   
2414   B4                     OR   H   
2415   18 F3                  JR   and1   
2417                XOR_:        
2417   D1                     POP   DE   ; Bitwise XOR the top 2 elements of the stack
2418                XOR1:        
2418   E1                     POP   HL   
2419   7B                     LD   A,E   
241A   AD                     XOR   L   
241B   6F                     LD   L,A   
241C   7A                     LD   A,D   
241D   AC                     XOR   H   
241E   18 EA                  JR   and1   
2420                INV_:        ; Bitwise INVert the top member of the stack
2420   11 FF FF               LD   DE,$FFFF   ; by xoring with $FFFF
2423   18 F3                  JR   xor1   
2425                ADD_:        ; Add the top 2 members of the stack
2425   D1                     POP   DE   ; 10t
2426   E1                     POP   HL   ; 10t
2427   19                     ADD   HL,DE   ; 11t
2428   E5                     PUSH   HL   ; 11t
2429   FD E9                  JP   (IY)   ; 8t
242B                             ; 50t
242B   C3 44 27     ARRDEF_:   JP   arrDef   
242E   C3 FE 24     ARREND_:   JP   arrEnd   
2431   C3 58 25     BEGIN_:   JP   begin   
2434                CALL_:       
2434   60 69                  LD   HL,BC   
2436   CD E2 27               CALL   rpush   ; save Instruction Pointer
2439   0A                     LD   A,(BC)   
243A   CD 5D 27               CALL   getGroup1   
243D   4E                     LD   C,(HL)   
243E   23                     INC   HL   
243F   46                     LD   B,(HL)   
2440   0B                     DEC   BC   
2441   FD E9                  JP   (IY)   ; Execute code from User def
2443   C3 68 27     DEF_:     JP   def   
2446                HDOT_:       ; print hexadecimal
2446   E1                     POP   HL   
2447   CD E5 21               CALL   printhex   
244A   18 04                  JR   dot2   
244C                DOT_:        
244C   E1                     POP   HL   
244D   CD DB 25               CALL   printdec   
2450                DOT2:        
2450   CD D9 27               CALL   space   
2453   FD E9                  JP   (IY)   
2455                DROP_:       ; Discard the top member of the stack
2455   E1                     POP   HL   
2456   FD E9                  JP   (IY)   
2458                DUP_:        
2458   E1                     POP   HL   ; Duplicate the top member of the stack
2459   E5                     PUSH   HL   
245A   E5                     PUSH   HL   
245B   FD E9                  JP   (IY)   
245D                ETX_:        
245D   C3 37 27               JP   etx   
2460                EXIT_:       
2460   03                     INC   BC   
2461   50 59                  LD   DE,BC   
2463   CD ED 27               CALL   rpop   ; Restore Instruction pointer
2466   44 4D                  LD   BC,HL   
2468   EB                     EX   DE,HL   
2469   E9                     JP   (HL)   
246A                FETCH_:      ; Fetch the value from the address placed on the top of the stack
246A   E1                     POP   HL   ; 10t
246B                FETCH1:      
246B   5E                     LD   E,(HL)   ; 7t
246C   23                     INC   HL   ; 6t
246D   56                     LD   D,(HL)   ; 7t
246E   D5                     PUSH   DE   ; 11t
246F   FD E9                  JP   (IY)   ; 8t
2471   C3 87 27     HEX_:     JP   hex   
2474   C3 A4 21     NOP_:     JP   NEXT   ; hardwire white space to always go to NEXT (important for arrays)
2477                NUM_:        
2477   C3 B9 25               JP   number   
247A                OVER_:       
247A   E1                     POP   HL   ; Duplicate 2nd element of the stack
247B   D1                     POP   DE   
247C   D5                     PUSH   DE   
247D   E5                     PUSH   HL   
247E   D5                     PUSH   DE   ; And push it to top of stack
247F   FD E9                  JP   (IY)   
2481                RET_:        
2481   CD ED 27               CALL   rpop   ; Restore Instruction pointer
2484   44 4D                  LD   BC,HL   
2486   FD E9                  JP   (IY)   
2488                STORE_:      ; Store the value at the address placed on the top of the stack
2488   E1                     POP   HL   ; 10t
2489   D1                     POP   DE   ; 10t
248A   73                     LD   (HL),E   ; 7t
248B   23                     INC   HL   ; 6t
248C   72                     LD   (HL),D   ; 7t
248D   FD E9                  JP   (IY)   ; 8t
248F                             ; 48t
248F                             ; $ swap                    ; a b -- b a Swap the top 2 elements of the stack
248F                SWAP_:       
248F   E1                     POP   HL   
2490   E3                     EX   (SP),HL   
2491   E5                     PUSH   HL   
2492   FD E9                  JP   (IY)   
2494                             ;  Left shift { is multply by 2		
2494                SHL_:        
2494   E1                     POP   HL   ; Duplicate the top member of the stack
2495   29                     ADD   HL,HL   
2496   E5                     PUSH   HL   ; shift left fallthrough into add_
2497   FD E9                  JP   (IY)   ; 8t
2499                             ;  Right shift } is a divide by 2		
2499                             ; 
2499                SHR_:        
2499   E1                     POP   HL   ; Get the top member of the stack
249A   CB 3C                  SRL   H   
249C   CB 1D                  RR   L   
249E   E5                     PUSH   HL   
249F   FD E9                  JP   (IY)   ; 8t
24A1   21 00 00     NEG_:     LD   HL,0   ; NEGate the value on top of stack (2's complement)
24A4   D1                     POP   DE   ; 10t
24A5   18 02                  JR   SUB_2   ; use the SUBtract routine
24A7                SUB_:        ; Subtract the value 2nd on stack from top of stack
24A7   D1                     POP   DE   ; 10t
24A8   E1           SUB_1:    POP   HL   ; 10t  Entry point for INVert
24A9   A7           SUB_2:    AND   A   ;  4t  Entry point for NEGate
24AA   ED 52                  SBC   HL,DE   ; 15t
24AC   E5                     PUSH   HL   ; 11t
24AD   FD E9                  JP   (IY)   ; 8t
24AF                             ; 58t
24AF   E1           EQ_:      POP   HL   
24B0   D1                     POP   DE   
24B1   A7                     AND   A   ; reset the carry flag
24B2   ED 52                  SBC   HL,DE   ; only equality sets HL=0 here
24B4   28 19                  JR   Z,equal   
24B6   21 00 00               LD   HL,0   
24B9   18 15                  JR   less   ; HL = 1
24BB                GETREF_:      
24BB   C3 C0 21               JP   getRef   
24BE   D1           GT_:      POP   DE   
24BF   E1                     POP   HL   
24C0   18 02                  JR   cmp_   
24C2   E1           LT_:      POP   HL   
24C3   D1                     POP   DE   
24C4   A7           CMP_:     AND   A   ; reset the carry flag
24C5   ED 52                  SBC   HL,DE   ; only equality sets HL=0 here
24C7   28 07                  JR   Z,less   ; equality returns 0  KB 25/11/21
24C9   21 00 00               LD   HL,0   
24CC   FA D0 24               JP   M,less   
24CF   2C           EQUAL:    INC   L   ; HL = 1
24D0                LESS:        
24D0   E5                     PUSH   HL   
24D1   FD E9                  JP   (IY)   
24D3                VAR_:        
24D3   0A                     LD   A,(BC)   
24D4   D6 21                  SUB   "a" - ((VARS - mintVars)/2)   
24D6   87                     ADD   A,A   
24D7   6F                     LD   L,A   
24D8   26 3A                  LD   H,msb(mintVars)   
24DA   E5                     PUSH   HL   
24DB   FD E9                  JP   (IY)   
24DD   18 57        DIV_:     JR   div   
24DF   18 39        MUL_:     JR   mul   
24E1   C3 86 25     AGAIN_:   JP   again   
24E4                STR_:        
24E4                STR:         ;= 15
24E4   03                     INC   BC   
24E5                NEXTCHAR:      
24E5   0A                     LD   A,(BC)   
24E6   03                     INC   BC   
24E7   FE 60                  CP   "`"   ; ` is the string terminator
24E9   28 05                  JR   Z,str2   
24EB   CD 5C 20               CALL   putchar   
24EE   18 F5                  JR   nextchar   
24F0                STR2:        
24F0   0B                     DEC   BC   
24F1   FD E9                  JP   (IY)   
24F3                             ;*******************************************************************
24F3                             ; Page 5 primitive routines
24F3                             ;*******************************************************************
24F3                             ;falls through
24F3                ALT:         ;= 11
24F3   03                     INC   BC   
24F4   0A                     LD   A,(BC)   
24F5   21 80 23               LD   HL,altCodes   
24F8   85                     ADD   A,L   
24F9   6F                     LD   L,A   
24FA   6E                     LD   L,(HL)   ; 7t    get low jump address
24FB   26 26                  LD   H,msb(page6)   ; Load H with the 5th page address
24FD   E9                     JP   (HL)   ; 4t    Jump to routine
24FE                             ; end a word array
24FE                ARREND:      ;= 27
24FE   CD ED 27               CALL   rpop   ; DE = start of array
2501   E5                     PUSH   HL   
2502   EB                     EX   DE,HL   
2503   2A 0E 3A               LD   HL,(vHeapPtr)   ; HL = heap ptr
2506   B7                     OR   A   
2507   ED 52                  SBC   HL,DE   ; bytes on heap
2509   3A 36 3A               LD   A,(vByteMode)   
250C   B7                     OR   A   
250D   20 04                  JR   NZ,arrEnd2   
250F   CB 3C                  SRL   H   ; BC = m words
2511   CB 1D                  RR   L   
2513                ARREND2:      
2513   E5                     PUSH   HL   
2514   FD 21 A4 21            LD   IY,NEXT   
2518   FD E9                  JP   (IY)   ; hardwired to NEXT
251A                             ; ********************************************************************
251A                             ; 16-bit multiply
251A                MUL:         ; 19
251A   D1                     POP   DE   ; get first value
251B   E1                     POP   HL   
251C   C5                     PUSH   BC   ; Preserve the IP
251D   44                     LD   B,H   ; BC = 2nd value
251E   4D                     LD   C,L   
251F   21 00 00               LD   HL,0   
2522   3E 10                  LD   A,16   
2524                MUL_LOOP_1:      
2524   29                     ADD   HL,HL   
2525   CB 13                  RL   E   
2527   CB 12                  RL   D   
2529   30 04                  JR   NC,$+6   
252B   09                     ADD   HL,BC   
252C   30 01                  JR   NC,$+3   
252E   13                     INC   DE   
252F   3D                     DEC   A   
2530   20 F2                  JR   NZ,Mul_Loop_1   
2532                             ; 
2532   C1                     POP   BC   ; Restore the IP
2533   E5                     PUSH   HL   ; Put the product on the stack - stack bug fixed 2/12/21
2534                             ; 
2534   FD E9                  JP   (IY)   
2536                             ; ********************************************************************
2536                             ; 16-bit division subroutine.
2536                             ; 
2536                             ; BC: divisor, DE: dividend, HL: remainder
2536                             ; *********************************************************************
2536                             ; This divides DE by BC, storing the result in DE, remainder in HL
2536                             ; *********************************************************************
2536                             ; 1382 cycles
2536                             ; 35 bytes (reduced from 48)
2536                             ; 
2536                DIV:         ; 24
2536   D1                     POP   DE   ; get first value
2537   E1                     POP   HL   ; get 2nd value
2538   C5                     PUSH   BC   ; Preserve the IP
2539   44                     LD   B,H   ; BC = 2nd value
253A   4D                     LD   C,L   
253B                             ; 
253B   21 00 00               LD   hl,0   ; Zero the remainder
253E   3E 10                  LD   a,16   ; Loop counter
2540                DIV_LOOP:      ;shift the bits from BC (numerator) into HL (accumulator)
2540   CB 21                  SLA   c   
2542   CB 10                  RL   b   
2544   ED 6A                  ADC   hl,hl   
2546   ED 52                  SBC   hl,de   ;Check if remainder >= denominator (HL>=DE)
2548   38 03                  JR   c,div_adjust   
254A   0C                     INC   c   
254B   18 01                  JR   div_done   
254D                DIV_ADJUST:      ; remainder is not >= denominator, so we have to add DE back to HL
254D   19                     ADD   hl,de   
254E                DIV_DONE:      
254E   3D                     DEC   a   
254F   20 EF                  JR   nz,div_loop   
2551   50                     LD   D,B   ; Result from BC to DE
2552   59                     LD   E,C   
2553                DIV_END:      
2553   C1                     POP   BC   ; Restore the IP
2554   D5                     PUSH   DE   ; Push Result
2555   E5                     PUSH   HL   ; Push remainder
2556   FD E9                  JP   (IY)   
2558                             ; *************************************
2558                             ; Loop Handling Code
2558                             ; *************************************
2558                             ;= 23
2558                BEGIN:       ; Left parentesis begins a loop
2558   E1                     POP   HL   
2559   7D                     LD   A,L   ; zero?
255A   B4                     OR   H   
255B   28 1C                  JR   Z,begin1   
255D   2B                     DEC   HL   
255E   11 FA FF               LD   DE,-6   
2561   DD 19                  ADD   IX,DE   
2563   DD 36 00 00            LD   (IX+0),0   ; loop var
2567   DD 36 01 00            LD   (IX+1),0   
256B   DD 75 02               LD   (IX+2),L   ; loop limit
256E   DD 74 03               LD   (IX+3),H   
2571   DD 71 04               LD   (IX+4),C   ; loop address
2574   DD 70 05               LD   (IX+5),B   
2577   FD E9                  JP   (IY)   
2579                BEGIN1:      
2579   1E 01                  LD   E,1   
257B                BEGIN2:      
257B   03                     INC   BC   
257C   0A                     LD   A,(BC)   
257D   CD A4 27               CALL   nesting   
2580   AF                     XOR   A   
2581   B3                     OR   E   
2582   20 F7                  JR   NZ,begin2   
2584                BEGIN3:      
2584   FD E9                  JP   (IY)   
2586                AGAIN:       
2586   DD 5E 00               LD   E,(IX+0)   ; peek loop var
2589   DD 56 01               LD   D,(IX+1)   
258C   7A                     LD   A,D   ; check if IFTEMode
258D   A3                     AND   E   
258E   3C                     INC   A   
258F   20 07                  JR   NZ,again1   
2591   13                     INC   DE   
2592   D5                     PUSH   DE   ; push FALSE condition
2593   11 02 00               LD   DE,2   
2596   18 1D                  JR   again3   ; drop IFTEMode
2598                AGAIN1:      
2598   DD 6E 02               LD   L,(IX+2)   ; peek loop limit
259B   DD 66 03               LD   H,(IX+3)   
259E   B7                     OR   A   
259F   ED 52                  SBC   HL,DE   
25A1   28 0F                  JR   Z,again2   
25A3   13                     INC   DE   
25A4   DD 73 00               LD   (IX+0),E   ; poke loop var
25A7   DD 72 01               LD   (IX+1),D   
25AA   DD 4E 04               LD   C,(IX+4)   ; peek loop address
25AD   DD 46 05               LD   B,(IX+5)   
25B0   FD E9                  JP   (IY)   
25B2                AGAIN2:      
25B2   11 06 00               LD   DE,6   ; drop loop frame
25B5                AGAIN3:      
25B5   DD 19                  ADD   IX,DE   
25B7   FD E9                  JP   (IY)   
25B9                             ; ********************************************************************************
25B9                             ; Number Handling Routine - converts numeric ascii string to a 16-bit number in HL
25B9                             ; Read the first character.
25B9                             ;			
25B9                             ; Number characters ($30 to $39) are converted to digits by subtracting $30
25B9                             ; and then added into the L register. (HL forms a 16-bit accumulator)
25B9                             ; Fetch the next character, if it is a number, multiply contents of HL by 10
25B9                             ; and then add in the next digit. Repeat this until a non-number character is
25B9                             ; detected. Add in the final digit so that HL contains the converted number.
25B9                             ; Push HL onto the stack and proceed to the dispatch routine.
25B9                             ; ********************************************************************************
25B9                NUMBER:      ;= 23
25B9   21 00 00               LD   HL,$0000   ; 10t Clear HL to accept the number
25BC   0A                     LD   A,(BC)   ; 7t  Get the character which is a numeral
25BD                NUMBER1:      ; corrected KB 24/11/21
25BD   D6 30                  SUB   $30   ; 7t    Form decimal digit
25BF   85                     ADD   A,L   ; 4t    Add into bottom of HL
25C0   6F                     LD   L,A   ; 4t
25C1   3E 00                  LD   A,00   ; 4t    Clear A
25C3   8C                     ADC   A,H   ; Add with carry H-reg
25C4   67                     LD   H,A   ; Put result in H-reg
25C5   03                     INC   BC   ; 6t    Increment IP
25C6   0A                     LD   A,(BC)   ; 7t    and get the next character
25C7   FE 30                  CP   $30   ; 7t    Less than $30
25C9   38 0C                  JR   C,endnum   ; 7/12t Not a number / end of number
25CB   FE 3A                  CP   $3A   ; 7t    Greater or equal to $3A
25CD   30 08                  JR   NC,endnum   ; 7/12t Not a number / end of number
25CF                TIMES10:      ; Multiply digit(s) in HL by 10
25CF   29                     ADD   HL,HL   ; 11t    2X
25D0   5D                     LD   E,L   ;  4t    LD DE,HL
25D1   54                     LD   D,H   ;  4t
25D2   29                     ADD   HL,HL   ; 11t    4X
25D3   29                     ADD   HL,HL   ; 11t    8X
25D4   19                     ADD   HL,DE   ; 11t    2X  + 8X  = 10X
25D5                             ; 52t cycles
25D5   18 E6                  JR   number1   
25D7                ENDNUM:      
25D7   0B                     DEC   BC   
25D8   E5                     PUSH   HL   ; 11t   Put the number on the stack
25D9   FD E9                  JP   (IY)   ; and process the next character
25DB                PRINTDEC:      
25DB                             ;Number in hl to decimal ASCII
25DB                             ;inputs:	hl = number to ASCII
25DB                             ;example: hl=300 outputs "00300"
25DB                             ;destroys: af, de, hl
25DB                DISPHL:      ;= 36
25DB   11 F0 D8               LD   de,-10000   
25DE   CD F4 25               CALL   Num1   
25E1   11 18 FC               LD   de,-1000   
25E4   CD F4 25               CALL   Num1   
25E7   11 9C FF               LD   de,-100   
25EA   CD F4 25               CALL   Num1   
25ED   1E F6                  LD   e,-10   
25EF   CD F4 25               CALL   Num1   
25F2   1E FF                  LD   e,-1   
25F4                NUM1:        
25F4   3E 2F                  LD   a,"0"-1   
25F6                NUM2:        
25F6   3C                     INC   a   
25F7   19                     ADD   hl,de   
25F8   38 FC                  JR   c,Num2   
25FA   ED 52                  SBC   hl,de   
25FC   C3 5C 20               JP   putchar   
25FF                             ; **************************************************************************
25FF                             ; Page 6 Alt primitives
25FF                             ; **************************************************************************
25FF                          ALIGN   $100   
2600                PAGE6:       
2600                CARRDEF_:      ; define a byte array
2600   3E 01                  LD   A,TRUE   
2602   C3 46 27               JP   arrDef1   
2605                CFETCH_:      
2605   E1                     POP   HL   ; 10t
2606   16 00                  LD   D,0   ; 7t
2608   5E                     LD   E,(HL)   ; 7t
2609   D5                     PUSH   DE   ; 11t
260A                ANOP_:       
260A   FD E9                  JP   (IY)   ; 8t
260C                             ; 49t
260C                CHARCODE_:      
260C   03                     INC   BC   
260D   0A                     LD   A,(BC)   
260E   26 00                  LD   H,0   
2610   6F                     LD   L,A   
2611   E5                     PUSH   HL   
2612   FD E9                  JP   (IY)   
2614                COMMENT_:      
2614   03                     INC   BC   ; point to next char
2615   0A                     LD   A,(BC)   
2616   FE 0D                  CP   "\r"   ; terminate at cr
2618   20 FA                  JR   NZ,comment_   
261A                             ; CP "\n"             ; terminate at lf
261A                             ; JR NZ,comment_
261A   0B                     DEC   BC   
261B   FD E9                  JP   (IY)   
261D                CSTORE_:      
261D   E1                     POP   HL   ; 10t
261E   D1                     POP   DE   ; 10t
261F   73                     LD   (HL),E   ; 7t
2620   FD E9                  JP   (IY)   ; 8t
2622                             ; 48t
2622                DEPTH_:      
2622   21 00 00               LD   HL,0   
2625   39                     ADD   HL,SP   
2626   EB                     EX   DE,HL   
2627   21 80 38               LD   HL,DSTACK   
262A   B7                     OR   A   
262B   ED 52                  SBC   HL,DE   
262D   38 04                  JR   C,depth2   
262F   CB 3C                  SRL   H   
2631   CB 1D                  RR   L   
2633                DEPTH2:      
2633   E5                     PUSH   HL   
2634   FD E9                  JP   (IY)   
2636                EMIT_:       
2636   E1                     POP   HL   
2637   7D                     LD   A,L   
2638   CD 5C 20               CALL   putchar   
263B   FD E9                  JP   (IY)   
263D                IFTE_:       
263D   D1                     POP   DE   
263E   7B                     LD   A,E   
263F   B2                     OR   D   
2640   C2 48 26               JP   NZ,ifte1   
2643   13                     INC   DE   
2644   D5                     PUSH   DE   ; push TRUE on stack for else clause
2645   C3 79 25               JP   begin1   ; skip to closing ) works with \) too
2648                IFTE1:       
2648   21 FF FF               LD   HL,-1   ; push -1 on return stack to indicate IFTEMode
264B   CD E2 27               CALL   rpush   
264E   FD E9                  JP   (IY)   
2650                EXEC_:       
2650   CD 55 26               CALL   exec1   
2653   FD E9                  JP   (IY)   
2655                EXEC1:       
2655   E1                     POP   HL   
2656   E3                     EX   (SP),HL   
2657   E9                     JP   (HL)   
2658                GO_:         
2658   60 69                  LD   HL,BC   
265A   CD E2 27               CALL   rpush   ; save Instruction Pointer
265D   C1                     POP   BC   
265E   0B                     DEC   BC   
265F   FD E9                  JP   (IY)   ; Execute code from User def
2661                ENDGROUP_:      
2661   CD ED 27               CALL   rpop   
2664   22 06 3A               LD   (vDEFS),HL   
2667   FD E9                  JP   (IY)   
2669                GROUP_:      
2669   D1                     POP   DE   
266A   53                     LD   D,E   
266B   1E 00                  LD   E,0   
266D   CB 3A                  SRL   D   
266F   CB 1B                  RR   E   
2671   CB 3A                  SRL   D   
2673   CB 1B                  RR   E   
2675   2A 06 3A               LD   HL,(vDEFS)   
2678   CD E2 27               CALL   rpush   
267B   21 C0 3A               LD   HL,DEFS   
267E   19                     ADD   HL,DE   
267F   22 06 3A               LD   (vDEFS),HL   
2682   FD E9                  JP   (IY)   ; Execute code from User def
2684                SYSVAR_:      
2684   0A                     LD   A,(BC)   
2685   D6 61                  SUB   "a" - ((sysVars - mintVars)/2)   
2687   87                     ADD   A,A   
2688   6F                     LD   L,A   
2689   26 3A                  LD   H,msb(mintVars)   
268B   E5                     PUSH   HL   
268C   FD E9                  JP   (IY)   ; Execute code from User def
268E                I_:          
268E   DD E5                  PUSH   IX   
2690   FD E9                  JP   (IY)   
2692                             ; \+    a b -- [b]+a            ; increment variable at b by a
2692                INCR_:       
2692   E1                     POP   HL   
2693   D1                     POP   DE   
2694   7B                     LD   A,E   
2695   86                     ADD   A,(HL)   
2696   77                     LD   (HL),A   
2697   23                     INC   HL   
2698   7A                     LD   A,D   
2699   8E                     ADC   A,(HL)   
269A   77                     LD   (HL),A   
269B   FD E9                  JP   (IY)   
269D                INPORT_:      
269D   E1                     POP   HL   
269E   79                     LD   A,C   
269F   4D                     LD   C,L   
26A0   ED 68                  IN   L,(C)   
26A2   26 00                  LD   H,0   
26A4   4F                     LD   C,A   
26A5   E5                     PUSH   HL   
26A6   FD E9                  JP   (IY)   
26A8                J_:          
26A8   DD E5                  PUSH   IX   
26AA   E1                     POP   HL   
26AB   11 06 00               LD   DE,6   
26AE   19                     ADD   HL,DE   
26AF   E5                     PUSH   HL   
26B0   FD E9                  JP   (IY)   
26B2                KEY_:        
26B2   CD 58 20               CALL   getchar   
26B5   6F                     LD   L,A   
26B6   26 00                  LD   H,0   
26B8   E5                     PUSH   HL   
26B9   FD E9                  JP   (IY)   
26BB                NEWLN_:      
26BB   CD D0 27               CALL   crlf   
26BE   FD E9                  JP   (IY)   
26C0                OUTPORT_:      
26C0   E1                     POP   HL   
26C1   59                     LD   E,C   
26C2   4D                     LD   C,L   
26C3   E1                     POP   HL   
26C4   ED 69                  OUT   (C),L   
26C6   4B                     LD   C,E   
26C7   FD E9                  JP   (IY)   
26C9                ROT_:        ; a b c -- b c a
26C9   D1                     POP   DE   ; a b                   de = c
26CA   E1                     POP   HL   ; a                     hl = b
26CB   E3                     EX   (SP),HL   ; b                     hl = a
26CC   D5                     PUSH   DE   ; b c
26CD   E5                     PUSH   HL   ; b c a
26CE   FD E9                  JP   (IY)   
26D0                             ; sign_:
26D0                             ;         POP HL
26D0                             ;         BIT 7,H
26D0                             ;         LD HL,0
26D0                             ;         JR Z, sign2
26D0                             ;         INC HL
26D0                             ; sign2:
26D0                             ;         PUSH HL
26D0                             ; JP (IY)
26D0                BREAK_:      
26D0   E1                     POP   HL   
26D1   7D                     LD   A,L   ; zero?
26D2   B4                     OR   H   
26D3   20 02                  JR   NZ,break1   
26D5   FD E9                  JP   (IY)   
26D7                BREAK1:      
26D7   11 06 00               LD   DE,6   ; drop loop frame
26DA   DD 19                  ADD   IX,DE   
26DC   C3 79 25               JP   begin1   ; skip to end of loop
26DF                PRINTSTK_:      
26DF   18 36                  JR   printStk   
26E1                EDITDEF_:      
26E1                             ; **************************************************************************
26E1                             ; Page 6 primitive routines
26E1                             ; **************************************************************************
26E1                             ; falls through
26E1                             ; **************************************************************************
26E1                             ; copy definition to text input buffer
26E1                             ; update TIBPtr
26E1                             ; **************************************************************************
26E1                EDITDEF:      ; lookup up def based on number
26E1   3E 41                  LD   A,"A"   
26E3   D1                     POP   DE   
26E4   83                     ADD   A,E   
26E5   08                     EX   AF,AF'   
26E6   2A 06 3A               LD   HL,(vDEFS)   
26E9   19                     ADD   HL,DE   
26EA   19                     ADD   HL,DE   
26EB   5E                     LD   E,(HL)   
26EC   23                     INC   HL   
26ED   56                     LD   D,(HL)   
26EE   EB                     EX   DE,HL   
26EF   7E                     LD   A,(HL)   
26F0   FE 3B                  CP   ";"   
26F2   11 00 39               LD   DE,TIB   
26F5   28 14                  JR   Z,editDef3   
26F7   3E 3A                  LD   A,":"   
26F9   CD DD 27               CALL   writeChar   
26FC   08                     EX   AF,AF'   
26FD   CD DD 27               CALL   writeChar   
2700   18 01                  JR   editDef2   
2702                EDITDEF1:      
2702   23                     INC   HL   
2703                EDITDEF2:      
2703   7E                     LD   A,(HL)   
2704   CD DD 27               CALL   writeChar   
2707   FE 3B                  CP   ";"   
2709   20 F7                  JR   NZ,editDef1   
270B                EDITDEF3:      
270B   21 00 39               LD   HL,TIB   
270E   EB                     EX   DE,HL   
270F   B7                     OR   A   
2710   ED 52                  SBC   HL,DE   
2712   22 04 3A               LD   (vTIBPtr),HL   
2715   FD E9                  JP   (IY)   
2717                PRINTSTK:      ;= 40
2717   CD C8 21               CALL   ENTER   
271A   5C 61 40 32 2D 5C 44 31 2D 28 22 40 5C 62 40 5C 28 2C 29 28 2E 29 32 2D 29 27 00 .CSTR   "\\a@2-\\D1-(",$22,"@\\b@\\(,)(.)2-)'"   
2735   FD E9                  JP   (IY)   
2737                             ;*******************************************************************
2737                             ; Page 5 primitive routines continued
2737                             ;*******************************************************************
2737                ETX:         
2737   21 80 C7               LD   HL,-DSTACK   
273A   39                     ADD   HL,SP   
273B   D2 41 27               JP   NC,etx1   
273E   31 80 38               LD   SP,DSTACK   
2741                ETX1:        
2741   C3 3E 21               JP   interpret   
2744                             ; define a word array
2744                ARRDEF:      ;= 18
2744   3E 00                  LD   A,FALSE   
2746                ARRDEF1:      
2746   FD 21 AD 21            LD   IY,compNEXT   
274A   32 36 3A               LD   (vByteMode),A   
274D   2A 0E 3A               LD   HL,(vHeapPtr)   ; HL = heap ptr
2750   CD E2 27               CALL   rpush   ; save start of array \[  \]
2753   C3 A4 21               JP   NEXT   ; hardwired to NEXT
2756                GETGROUP:      ;= 11
2756   D6 41                  SUB   "A"   
2758   32 08 3A               LD   (vEdited),A   
275B   18 02                  JR   getGroup2   
275D                GETGROUP1:      
275D   D6 41                  SUB   "A"   
275F                GETGROUP2:      
275F   87                     ADD   A,A   
2760   5F                     LD   E,A   
2761   16 00                  LD   D,0   
2763   2A 06 3A               LD   HL,(vDEFS)   
2766   19                     ADD   HL,DE   
2767   C9                     RET      
2768                             ; **************************************************************************
2768                             ; def is used to create a colon definition
2768                             ; When a colon is detected, the next character (usually uppercase alpha)
2768                             ; is looked up in the vector table to get its associated code field address
2768                             ; This CFA is updated to point to the character after uppercase alpha
2768                             ; The remainder of the characters are then skipped until after a semicolon
2768                             ; is found.
2768                             ; ***************************************************************************
2768                             ;= 31
2768                DEF:         ; Create a colon definition
2768   03                     INC   BC   
2769   0A                     LD   A,(BC)   ; Get the next character
276A   03                     INC   BC   
276B   CD 56 27               CALL   getGroup   
276E   ED 5B 0E 3A            LD   DE,(vHeapPtr)   ; start of defintion
2772   73                     LD   (HL),E   ; Save low byte of address in CFA
2773   23                     INC   HL   
2774   72                     LD   (HL),D   ; Save high byte of address in CFA+1
2775                DEF1:        ; Skip to end of definition
2775   0A                     LD   A,(BC)   ; Get the next character
2776   03                     INC   BC   ; Point to next character
2777   12                     LD   (DE),A   
2778   13                     INC   DE   
2779   FE 3B                  CP   ";"   ; Is it a semicolon
277B   CA 80 27               JP   z,def2   ; end the definition
277E   18 F5                  JR   def1   ; get the next element
2780                DEF2:        
2780   0B                     DEC   BC   
2781                DEF3:        
2781   ED 53 0E 3A            LD   (vHeapPtr),DE   ; bump heap ptr to after definiton
2785   FD E9                  JP   (IY)   
2787                HEX:         ;= 26
2787   21 00 00               LD   HL,0   ; 10t Clear HL to accept the number
278A                HEX1:        
278A   03                     INC   BC   
278B   0A                     LD   A,(BC)   ; 7t  Get the character which is a numeral
278C   CB 77                  BIT   6,A   ; 7t    is it uppercase alpha?
278E   28 02                  JR   Z,hex2   ; no a decimal
2790   D6 07                  SUB   7   ; sub 7  to make $A - $F
2792                HEX2:        
2792   D6 30                  SUB   $30   ; 7t    Form decimal digit
2794   DA D7 25               JP   C,endnum   
2797   FE 10                  CP   $0F+1   
2799   D2 D7 25               JP   NC,endnum   
279C   29                     ADD   HL,HL   ; 11t    2X ; Multiply digit(s) in HL by 16
279D   29                     ADD   HL,HL   ; 11t    4X
279E   29                     ADD   HL,HL   ; 11t    8X
279F   29                     ADD   HL,HL   ; 11t   16X
27A0   85                     ADD   A,L   ; 4t    Add into bottom of HL
27A1   6F                     LD   L,A   ; 4t
27A2   18 E6                  JR   hex1   
27A4                             ; **************************************************************************
27A4                             ; calculate nesting value
27A4                             ; A is char to be tested,
27A4                             ; E is the nesting value (initially 0)
27A4                             ; E is increased by ( and [
27A4                             ; E is decreased by ) and ]
27A4                             ; E has its bit 7 toggled by `
27A4                             ; limited to 127 levels
27A4                             ; **************************************************************************
27A4                NESTING:      ;= 44
27A4   FE 60                  CP   "`"   
27A6   20 0A                  JR   NZ,nesting1   
27A8   CB 7B                  BIT   7,E   
27AA   28 03                  JR   Z,nesting1a   
27AC   CB BB                  RES   7,E   
27AE   C9                     RET      
27AF                NESTING1A:      
27AF   CB FB                  SET   7,E   
27B1   C9                     RET      
27B2                NESTING1:      
27B2   CB 7B                  BIT   7,E   
27B4   C0                     RET   NZ   
27B5   FE 3A                  CP   ":"   
27B7   28 08                  JR   Z,nesting2   
27B9   FE 5B                  CP   "["   
27BB   28 04                  JR   Z,nesting2   
27BD   FE 28                  CP   "("   
27BF   20 02                  JR   NZ,nesting3   
27C1                NESTING2:      
27C1   1C                     INC   E   
27C2   C9                     RET      
27C3                NESTING3:      
27C3   FE 3B                  CP   ";"   
27C5   28 07                  JR   Z,nesting4   
27C7   FE 5D                  CP   "]"   
27C9   28 03                  JR   Z,nesting4   
27CB   FE 29                  CP   ")"   
27CD   C0                     RET   NZ   
27CE                NESTING4:      
27CE   1D                     DEC   E   
27CF   C9                     RET      
27D0                CRLF:        ; 18
27D0   3E 0D                  LD   A,"\r"   
27D2   CD 5C 20               CALL   putchar   
27D5   3E 0A                  LD   A,"\n"   
27D7   18 06                  JR   writeChar1   
27D9                SPACE:       
27D9   3E 20                  LD   A," "   
27DB   18 02                  JR   writeChar1   
27DD                WRITECHAR:      
27DD   12                     LD   (DE),A   
27DE   13                     INC   DE   
27DF                WRITECHAR1:      
27DF   C3 5C 20               JP   putchar   
27E2                RPUSH:       ; 11
27E2   DD 2B                  DEC   IX   
27E4   DD 74 00               LD   (IX+0),H   
27E7   DD 2B                  DEC   IX   
27E9   DD 75 00               LD   (IX+0),L   
27EC   C9                     RET      
27ED                RPOP:        ; 11
27ED   DD 6E 00               LD   L,(IX+0)   
27F0   DD 23                  INC   IX   
27F2   DD 66 00               LD   H,(IX+0)   
27F5   DD 23                  INC   IX   
27F7   C9                     RET      
3800                          .ORG   RAMSTART   
3800                          DS   DSIZE   
3880                STACK:       
3880                DSTACK:      
3880                          DS   RSIZE   
3900                RSTACK:      
3900                TIB:      DS   TIBSIZE   
3A00                          ALIGN   $100   
3A00                MINTVARS:      
3A00                SYSVARS:      
3A00                VS0:      DS   2   ; a
3A02                VBASE16:   DS   2   ; b
3A04                VTIBPTR:   DS   2   ; c
3A06                VDEFS:    DS   2   ; d
3A08                VEDITED:   DS   2   ; e
3A0A                          DS   2   ; f
3A0C                          DS   2   ; g
3A0E                VHEAPPTR:   DS   2   ; h
3A10                          DS   2   ; i
3A12                          DS   2   ; j
3A14                          DS   2   ; k
3A16                          DS   2   ; l
3A18                          DS   2   ; m
3A1A                          DS   2   ; n
3A1C                          DS   2   ; o
3A1E                          DS   2   ; p
3A20                          DS   2   ; q
3A22                          DS   2   ; r
3A24                          DS   2   ; s
3A26                          DS   2   ; t
3A28                          DS   2   ; u
3A2A                          DS   2   ; v
3A2C                          DS   2   ; w
3A2E                          DS   2   ; x
3A30                          DS   2   ; y
3A32                          DS   2   ; z
3A34                          DS   2   ; 
3A36                VBYTEMODE:   DS   2   ; 
3A38                          DS   $30   
3A68                TBPTR:    DS   2   ; reserved for tests
3A6A                RST08:    DS   2   
3A6C                RST10:    DS   2   
3A6E                RST18:    DS   2   
3A70                RST20:    DS   2   
3A72                RST28:    DS   2   
3A74                RST30:    DS   2   ; 
3A76                BAUD:     DS   2   ; 
3A78                INTVEC:   DS   2   ; 
3A7A                NMIVEC:   DS   2   ; 
3A7C                GETCVEC:   DS   2   ; 
3A7E                PUTCVEC:   DS   2   ; 
3A80                             ; ****************************************************************
3A80                             ; VARS Table - holds 26 16-bit user variables
3A80                             ; ****************************************************************
3A80                VARS:     DS   26 * 2   
3AB4                             ; ****************************************************************
3AB4                             ; DEFS Table - holds 26 addresses of user routines
3AB4                             ; ****************************************************************
3AB4                          ALIGN   $40   
3AB4                          .ORG   $-12   
3AB4                          DS   12   ; vars for group 0
3AC0                DEFS:     DS   GRPSIZE * NUMGRPS   
3C00                HEAP:        


PGMSTART:           2000 DEFINED AT LINE 15
                    > USED AT LINE 28
                    > USED AT LINE 41
                    > USED AT LINE 49
RAMSTART:           3800 DEFINED AT LINE 16
                    > USED AT LINE 1 IN ram.asm
IO0:                0080 DEFINED AT LINE 19
IO1:                0081 DEFINED AT LINE 20
IO2:                0082 DEFINED AT LINE 21
IO3:                0083 DEFINED AT LINE 22
DISPLY:             0084 DEFINED AT LINE 23
SCAN:               0085 DEFINED AT LINE 24
                    > USED AT LINE 28 IN BitBangSerial.asm
                    > USED AT LINE 50 IN BitBangSerial.asm
                    > USED AT LINE 60 IN BitBangSerial.asm
                    > USED AT LINE 66 IN BitBangSerial.asm
KEYBUF:             0086 DEFINED AT LINE 25
                    > USED AT LINE 89 IN BitBangSerial.asm
                    > USED AT LINE 98 IN BitBangSerial.asm
                    > USED AT LINE 107 IN BitBangSerial.asm
IO7:                0087 DEFINED AT LINE 26
SEVENSEGMENT:       2040 DEFINED AT LINE 42
GETCHAR:            2058 DEFINED AT LINE 59
                    > USED AT LINE 117 IN MINT.asm
                    > USED AT LINE 1165 IN MINT.asm
PUTCHAR:            205C DEFINED AT LINE 63
                    > USED AT LINE 132 IN MINT.asm
                    > USED AT LINE 233 IN MINT.asm
                    > USED AT LINE 754 IN MINT.asm
                    > USED AT LINE 1008 IN MINT.asm
                    > USED AT LINE 1069 IN MINT.asm
                    > USED AT LINE 1401 IN MINT.asm
                    > USED AT LINE 1413 IN MINT.asm
B300:               0220 DEFINED AT LINE 16 IN BitBangSerial.asm
B1200:              0080 DEFINED AT LINE 17 IN BitBangSerial.asm
B2400:              003F DEFINED AT LINE 18 IN BitBangSerial.asm
B4800:              001B DEFINED AT LINE 19 IN BitBangSerial.asm
                    > USED AT LINE 30 IN BitBangSerial.asm
B9600:              000B DEFINED AT LINE 20 IN BitBangSerial.asm
INITIALISESERIAL:   2062 DEFINED AT LINE 24 IN BitBangSerial.asm
                    > USED AT LINE 35
TXCHAR:             2075 DEFINED AT LINE 41 IN BitBangSerial.asm
                    > USED AT LINE 32
NXTBIT:             2086 DEFINED AT LINE 56 IN BitBangSerial.asm
                    > USED AT LINE 62 IN BitBangSerial.asm
RXCHAR:             20A0 DEFINED AT LINE 83 IN BitBangSerial.asm
                    > USED AT LINE 30
STARTBIT:           20A2 DEFINED AT LINE 88 IN BitBangSerial.asm
                    > USED AT LINE 91 IN BitBangSerial.asm
                    > USED AT LINE 100 IN BitBangSerial.asm
GETBITS:            20BA DEFINED AT LINE 104 IN BitBangSerial.asm
                    > USED AT LINE 110 IN BitBangSerial.asm
BITIME:             20CD DEFINED AT LINE 123 IN BitBangSerial.asm
                    > USED AT LINE 26 IN BitBangSerial.asm
                    > USED AT LINE 51 IN BitBangSerial.asm
                    > USED AT LINE 61 IN BitBangSerial.asm
                    > USED AT LINE 67 IN BitBangSerial.asm
                    > USED AT LINE 68 IN BitBangSerial.asm
                    > USED AT LINE 97 IN BitBangSerial.asm
                    > USED AT LINE 106 IN BitBangSerial.asm
BITIM1:             20D2 DEFINED AT LINE 127 IN BitBangSerial.asm
                    > USED AT LINE 129 IN BitBangSerial.asm
DSIZE:              0080 DEFINED AT LINE 17 IN MINT.asm
                    > USED AT LINE 3 IN ram.asm
RSIZE:              0080 DEFINED AT LINE 18 IN MINT.asm
                    > USED AT LINE 7 IN ram.asm
TIBSIZE:            0100 DEFINED AT LINE 19 IN MINT.asm
                    > USED AT LINE 10 IN ram.asm
TRUE:               0001 DEFINED AT LINE 20 IN MINT.asm
                    > USED AT LINE 1017 IN MINT.asm
FALSE:              0000 DEFINED AT LINE 21 IN MINT.asm
                    > USED AT LINE 45 IN MINT.asm
                    > USED AT LINE 1279 IN MINT.asm
NUMGRPS:            0005 DEFINED AT LINE 23 IN MINT.asm
                    > USED AT LINE 62 IN MINT.asm
                    > USED AT LINE 70 IN ram.asm
GRPSIZE:            0040 DEFINED AT LINE 24 IN MINT.asm
                    > USED AT LINE 62 IN MINT.asm
                    > USED AT LINE 70 IN ram.asm
START:              20DA DEFINED AT LINE 32 IN MINT.asm
                    > USED AT LINE 37
MINT:               20DA DEFINED AT LINE 33 IN MINT.asm
ISYSVARS:           20F4 DEFINED AT LINE 43 IN MINT.asm
                    > USED AT LINE 56 IN MINT.asm
INITIALIZE:         2104 DEFINED AT LINE 53 IN MINT.asm
                    > USED AT LINE 35 IN MINT.asm
INIT1:              211C DEFINED AT LINE 63 IN MINT.asm
                    > USED AT LINE 68 IN MINT.asm
MACRO:              2125 DEFINED AT LINE 71 IN MINT.asm
                    > USED AT LINE 125 IN MINT.asm
INTERPRET:          213E DEFINED AT LINE 84 IN MINT.asm
                    > USED AT LINE 38 IN MINT.asm
                    > USED AT LINE 1275 IN MINT.asm
INTERPRET1:         2148 DEFINED AT LINE 88 IN MINT.asm
INTERPRET2:         214F DEFINED AT LINE 92 IN MINT.asm
                    > USED AT LINE 82 IN MINT.asm
INTERPRET3:         2157 DEFINED AT LINE 99 IN MINT.asm
                    > USED AT LINE 108 IN MINT.asm
INTERPRET4:         215D DEFINED AT LINE 105 IN MINT.asm
                    > USED AT LINE 97 IN MINT.asm
WAITCHAR:           2162 DEFINED AT LINE 116 IN MINT.asm
                    > USED AT LINE 134 IN MINT.asm
                    > USED AT LINE 148 IN MINT.asm
WAITCHAR1:          2175 DEFINED AT LINE 127 IN MINT.asm
                    > USED AT LINE 119 IN MINT.asm
WAITCHAR3:          2183 DEFINED AT LINE 136 IN MINT.asm
                    > USED AT LINE 123 IN MINT.asm
WAITCHAR4:          2199 DEFINED AT LINE 152 IN MINT.asm
                    > USED AT LINE 121 IN MINT.asm
NEXT:               21A4 DEFINED AT LINE 180 IN MINT.asm
                    > USED AT LINE 55 IN MINT.asm
                    > USED AT LINE 156 IN MINT.asm
                    > USED AT LINE 202 IN MINT.asm
                    > USED AT LINE 642 IN MINT.asm
                    > USED AT LINE 790 IN MINT.asm
                    > USED AT LINE 1285 IN MINT.asm
COMPNEXT:           21AD DEFINED AT LINE 190 IN MINT.asm
                    > USED AT LINE 1281 IN MINT.asm
COMPNEXT1:          21BB DEFINED AT LINE 200 IN MINT.asm
                    > USED AT LINE 197 IN MINT.asm
GETREF:             21C0 DEFINED AT LINE 204 IN MINT.asm
                    > USED AT LINE 713 IN MINT.asm
ENTER:              21C8 DEFINED AT LINE 210 IN MINT.asm
                    > USED AT LINE 36 IN MINT.asm
                    > USED AT LINE 79 IN MINT.asm
                    > USED AT LINE 85 IN MINT.asm
                    > USED AT LINE 1262 IN MINT.asm
PRINT_HEX8:         21D1 DEFINED AT LINE 219 IN MINT.asm
                    > USED AT LINE 239 IN MINT.asm
                    > USED AT LINE 241 IN MINT.asm
CONV:               21DA DEFINED AT LINE 227 IN MINT.asm
                    > USED AT LINE 225 IN MINT.asm
PRINTHEX:           21E5 DEFINED AT LINE 235 IN MINT.asm
                    > USED AT LINE 602 IN MINT.asm
MACROS:             21F0 DEFINED AT LINE 249 IN MINT.asm
EMPTY_:             21F0 DEFINED AT LINE 1 IN MINT.asm
BACKSP_:            21F1 DEFINED AT LINE 4 IN MINT.asm
REEDIT_:            2206 DEFINED AT LINE 7 IN MINT.asm
EDIT_:              220D DEFINED AT LINE 10 IN MINT.asm
LIST_:              2220 DEFINED AT LINE 13 IN MINT.asm
PRINTSTACK_:        223C DEFINED AT LINE 16 IN MINT.asm
TOGGLEBASE_:        224D DEFINED AT LINE 19 IN MINT.asm
OPCODES:            2300 DEFINED AT LINE 258 IN MINT.asm
CTRLCODES:          2380 DEFINED AT LINE 395 IN MINT.asm
                    > USED AT LINE 73 IN MINT.asm
ALTCODES:           2380 DEFINED AT LINE 396 IN MINT.asm
                    > USED AT LINE 768 IN MINT.asm
PAGE4:              2400 DEFINED AT LINE 531 IN MINT.asm
ALT_:               2400 DEFINED AT LINE 533 IN MINT.asm
AND_:               2403 DEFINED AT LINE 536 IN MINT.asm
AND1:               240A DEFINED AT LINE 544 IN MINT.asm
                    > USED AT LINE 558 IN MINT.asm
                    > USED AT LINE 569 IN MINT.asm
OR_:                240E DEFINED AT LINE 550 IN MINT.asm
XOR_:               2417 DEFINED AT LINE 560 IN MINT.asm
XOR1:               2418 DEFINED AT LINE 562 IN MINT.asm
                    > USED AT LINE 573 IN MINT.asm
INV_:               2420 DEFINED AT LINE 571 IN MINT.asm
ADD_:               2425 DEFINED AT LINE 575 IN MINT.asm
ARRDEF_:            242B DEFINED AT LINE 583 IN MINT.asm
ARREND_:            242E DEFINED AT LINE 584 IN MINT.asm
BEGIN_:             2431 DEFINED AT LINE 585 IN MINT.asm
CALL_:              2434 DEFINED AT LINE 586 IN MINT.asm
DEF_:               2443 DEFINED AT LINE 598 IN MINT.asm
HDOT_:              2446 DEFINED AT LINE 600 IN MINT.asm
DOT_:               244C DEFINED AT LINE 604 IN MINT.asm
DOT2:               2450 DEFINED AT LINE 607 IN MINT.asm
                    > USED AT LINE 603 IN MINT.asm
DROP_:              2455 DEFINED AT LINE 611 IN MINT.asm
DUP_:               2458 DEFINED AT LINE 615 IN MINT.asm
ETX_:               245D DEFINED AT LINE 620 IN MINT.asm
EXIT_:              2460 DEFINED AT LINE 623 IN MINT.asm
FETCH_:             246A DEFINED AT LINE 631 IN MINT.asm
FETCH1:             246B DEFINED AT LINE 633 IN MINT.asm
                    > USED AT LINE 208 IN MINT.asm
HEX_:               2471 DEFINED AT LINE 640 IN MINT.asm
NOP_:               2474 DEFINED AT LINE 642 IN MINT.asm
NUM_:               2477 DEFINED AT LINE 644 IN MINT.asm
OVER_:              247A DEFINED AT LINE 647 IN MINT.asm
RET_:               2481 DEFINED AT LINE 655 IN MINT.asm
STORE_:             2488 DEFINED AT LINE 660 IN MINT.asm
SWAP_:              248F DEFINED AT LINE 669 IN MINT.asm
SHL_:               2494 DEFINED AT LINE 676 IN MINT.asm
SHR_:               2499 DEFINED AT LINE 684 IN MINT.asm
NEG_:               24A1 DEFINED AT LINE 691 IN MINT.asm
SUB_:               24A7 DEFINED AT LINE 695 IN MINT.asm
SUB_1:              24A8 DEFINED AT LINE 698 IN MINT.asm
SUB_2:              24A9 DEFINED AT LINE 699 IN MINT.asm
                    > USED AT LINE 693 IN MINT.asm
EQ_:                24AF DEFINED AT LINE 704 IN MINT.asm
GETREF_:            24BB DEFINED AT LINE 712 IN MINT.asm
GT_:                24BE DEFINED AT LINE 714 IN MINT.asm
LT_:                24C2 DEFINED AT LINE 718 IN MINT.asm
CMP_:               24C4 DEFINED AT LINE 720 IN MINT.asm
                    > USED AT LINE 716 IN MINT.asm
EQUAL:              24CF DEFINED AT LINE 725 IN MINT.asm
                    > USED AT LINE 708 IN MINT.asm
LESS:               24D0 DEFINED AT LINE 726 IN MINT.asm
                    > USED AT LINE 710 IN MINT.asm
                    > USED AT LINE 722 IN MINT.asm
                    > USED AT LINE 724 IN MINT.asm
VAR_:               24D3 DEFINED AT LINE 730 IN MINT.asm
DIV_:               24DD DEFINED AT LINE 741 IN MINT.asm
MUL_:               24DF DEFINED AT LINE 742 IN MINT.asm
AGAIN_:             24E1 DEFINED AT LINE 744 IN MINT.asm
STR_:               24E4 DEFINED AT LINE 745 IN MINT.asm
STR:                24E4 DEFINED AT LINE 746 IN MINT.asm
NEXTCHAR:           24E5 DEFINED AT LINE 749 IN MINT.asm
                    > USED AT LINE 755 IN MINT.asm
STR2:               24F0 DEFINED AT LINE 757 IN MINT.asm
                    > USED AT LINE 753 IN MINT.asm
ALT:                24F3 DEFINED AT LINE 765 IN MINT.asm
                    > USED AT LINE 534 IN MINT.asm
ARREND:             24FE DEFINED AT LINE 776 IN MINT.asm
                    > USED AT LINE 584 IN MINT.asm
ARREND2:            2513 DEFINED AT LINE 788 IN MINT.asm
                    > USED AT LINE 785 IN MINT.asm
MUL:                251A DEFINED AT LINE 795 IN MINT.asm
                    > USED AT LINE 742 IN MINT.asm
MUL_LOOP_1:         2524 DEFINED AT LINE 804 IN MINT.asm
                    > USED AT LINE 813 IN MINT.asm
DIV:                2536 DEFINED AT LINE 833 IN MINT.asm
                    > USED AT LINE 741 IN MINT.asm
DIV_LOOP:           2540 DEFINED AT LINE 843 IN MINT.asm
                    > USED AT LINE 858 IN MINT.asm
DIV_ADJUST:         254D DEFINED AT LINE 853 IN MINT.asm
                    > USED AT LINE 849 IN MINT.asm
DIV_DONE:           254E DEFINED AT LINE 856 IN MINT.asm
                    > USED AT LINE 851 IN MINT.asm
DIV_END:            2553 DEFINED AT LINE 863 IN MINT.asm
BEGIN:              2558 DEFINED AT LINE 875 IN MINT.asm
                    > USED AT LINE 585 IN MINT.asm
BEGIN1:             2579 DEFINED AT LINE 892 IN MINT.asm
                    > USED AT LINE 879 IN MINT.asm
                    > USED AT LINE 1079 IN MINT.asm
                    > USED AT LINE 1211 IN MINT.asm
BEGIN2:             257B DEFINED AT LINE 894 IN MINT.asm
                    > USED AT LINE 900 IN MINT.asm
BEGIN3:             2584 DEFINED AT LINE 901 IN MINT.asm
AGAIN:              2586 DEFINED AT LINE 904 IN MINT.asm
                    > USED AT LINE 744 IN MINT.asm
AGAIN1:             2598 DEFINED AT LINE 917 IN MINT.asm
                    > USED AT LINE 911 IN MINT.asm
AGAIN2:             25B2 DEFINED AT LINE 929 IN MINT.asm
                    > USED AT LINE 922 IN MINT.asm
AGAIN3:             25B5 DEFINED AT LINE 931 IN MINT.asm
                    > USED AT LINE 915 IN MINT.asm
NUMBER:             25B9 DEFINED AT LINE 948 IN MINT.asm
                    > USED AT LINE 645 IN MINT.asm
NUMBER1:            25BD DEFINED AT LINE 952 IN MINT.asm
                    > USED AT LINE 977 IN MINT.asm
TIMES10:            25CF DEFINED AT LINE 968 IN MINT.asm
ENDNUM:             25D7 DEFINED AT LINE 979 IN MINT.asm
                    > USED AT LINE 964 IN MINT.asm
                    > USED AT LINE 966 IN MINT.asm
                    > USED AT LINE 1344 IN MINT.asm
                    > USED AT LINE 1346 IN MINT.asm
PRINTDEC:           25DB DEFINED AT LINE 984 IN MINT.asm
                    > USED AT LINE 606 IN MINT.asm
DISPHL:             25DB DEFINED AT LINE 991 IN MINT.asm
NUM1:               25F4 DEFINED AT LINE 1001 IN MINT.asm
                    > USED AT LINE 993 IN MINT.asm
                    > USED AT LINE 995 IN MINT.asm
                    > USED AT LINE 997 IN MINT.asm
                    > USED AT LINE 999 IN MINT.asm
NUM2:               25F6 DEFINED AT LINE 1003 IN MINT.asm
                    > USED AT LINE 1006 IN MINT.asm
PAGE6:              2600 DEFINED AT LINE 1014 IN MINT.asm
CARRDEF_:           2600 DEFINED AT LINE 1016 IN MINT.asm
CFETCH_:            2605 DEFINED AT LINE 1020 IN MINT.asm
ANOP_:              260A DEFINED AT LINE 1025 IN MINT.asm
CHARCODE_:          260C DEFINED AT LINE 1028 IN MINT.asm
COMMENT_:           2614 DEFINED AT LINE 1036 IN MINT.asm
                    > USED AT LINE 1040 IN MINT.asm
CSTORE_:            261D DEFINED AT LINE 1046 IN MINT.asm
DEPTH_:             2622 DEFINED AT LINE 1052 IN MINT.asm
DEPTH2:             2633 DEFINED AT LINE 1062 IN MINT.asm
                    > USED AT LINE 1059 IN MINT.asm
EMIT_:              2636 DEFINED AT LINE 1066 IN MINT.asm
IFTE_:              263D DEFINED AT LINE 1072 IN MINT.asm
IFTE1:              2648 DEFINED AT LINE 1080 IN MINT.asm
                    > USED AT LINE 1076 IN MINT.asm
EXEC_:              2650 DEFINED AT LINE 1085 IN MINT.asm
EXEC1:              2655 DEFINED AT LINE 1088 IN MINT.asm
                    > USED AT LINE 1086 IN MINT.asm
GO_:                2658 DEFINED AT LINE 1093 IN MINT.asm
ENDGROUP_:          2661 DEFINED AT LINE 1100 IN MINT.asm
GROUP_:             2669 DEFINED AT LINE 1105 IN MINT.asm
SYSVAR_:            2684 DEFINED AT LINE 1120 IN MINT.asm
I_:                 268E DEFINED AT LINE 1129 IN MINT.asm
INCR_:              2692 DEFINED AT LINE 1134 IN MINT.asm
INPORT_:            269D DEFINED AT LINE 1146 IN MINT.asm
J_:                 26A8 DEFINED AT LINE 1156 IN MINT.asm
KEY_:               26B2 DEFINED AT LINE 1164 IN MINT.asm
NEWLN_:             26BB DEFINED AT LINE 1171 IN MINT.asm
OUTPORT_:           26C0 DEFINED AT LINE 1175 IN MINT.asm
ROT_:               26C9 DEFINED AT LINE 1184 IN MINT.asm
BREAK_:             26D0 DEFINED AT LINE 1202 IN MINT.asm
BREAK1:             26D7 DEFINED AT LINE 1208 IN MINT.asm
                    > USED AT LINE 1206 IN MINT.asm
PRINTSTK_:          26DF DEFINED AT LINE 1213 IN MINT.asm
EDITDEF_:           26E1 DEFINED AT LINE 1215 IN MINT.asm
EDITDEF:            26E1 DEFINED AT LINE 1225 IN MINT.asm
EDITDEF1:           2702 DEFINED AT LINE 1246 IN MINT.asm
                    > USED AT LINE 1252 IN MINT.asm
EDITDEF2:           2703 DEFINED AT LINE 1248 IN MINT.asm
                    > USED AT LINE 1245 IN MINT.asm
EDITDEF3:           270B DEFINED AT LINE 1253 IN MINT.asm
                    > USED AT LINE 1240 IN MINT.asm
PRINTSTK:           2717 DEFINED AT LINE 1261 IN MINT.asm
                    > USED AT LINE 1214 IN MINT.asm
ETX:                2737 DEFINED AT LINE 1269 IN MINT.asm
                    > USED AT LINE 621 IN MINT.asm
ETX1:               2741 DEFINED AT LINE 1274 IN MINT.asm
                    > USED AT LINE 1272 IN MINT.asm
ARRDEF:             2744 DEFINED AT LINE 1278 IN MINT.asm
                    > USED AT LINE 583 IN MINT.asm
ARRDEF1:            2746 DEFINED AT LINE 1280 IN MINT.asm
                    > USED AT LINE 1018 IN MINT.asm
GETGROUP:           2756 DEFINED AT LINE 1287 IN MINT.asm
                    > USED AT LINE 207 IN MINT.asm
                    > USED AT LINE 1314 IN MINT.asm
GETGROUP1:          275D DEFINED AT LINE 1291 IN MINT.asm
                    > USED AT LINE 590 IN MINT.asm
GETGROUP2:          275F DEFINED AT LINE 1293 IN MINT.asm
                    > USED AT LINE 1290 IN MINT.asm
DEF:                2768 DEFINED AT LINE 1310 IN MINT.asm
                    > USED AT LINE 598 IN MINT.asm
DEF1:               2775 DEFINED AT LINE 1319 IN MINT.asm
                    > USED AT LINE 1326 IN MINT.asm
DEF2:               2780 DEFINED AT LINE 1328 IN MINT.asm
                    > USED AT LINE 1325 IN MINT.asm
DEF3:               2781 DEFINED AT LINE 1330 IN MINT.asm
HEX:                2787 DEFINED AT LINE 1334 IN MINT.asm
                    > USED AT LINE 640 IN MINT.asm
HEX1:               278A DEFINED AT LINE 1336 IN MINT.asm
                    > USED AT LINE 1353 IN MINT.asm
HEX2:               2792 DEFINED AT LINE 1342 IN MINT.asm
                    > USED AT LINE 1340 IN MINT.asm
NESTING:            27A4 DEFINED AT LINE 1365 IN MINT.asm
                    > USED AT LINE 103 IN MINT.asm
                    > USED AT LINE 133 IN MINT.asm
                    > USED AT LINE 897 IN MINT.asm
NESTING1A:          27AF DEFINED AT LINE 1372 IN MINT.asm
                    > USED AT LINE 1369 IN MINT.asm
NESTING1:           27B2 DEFINED AT LINE 1375 IN MINT.asm
                    > USED AT LINE 1367 IN MINT.asm
NESTING2:           27C1 DEFINED AT LINE 1384 IN MINT.asm
                    > USED AT LINE 1379 IN MINT.asm
                    > USED AT LINE 1381 IN MINT.asm
NESTING3:           27C3 DEFINED AT LINE 1387 IN MINT.asm
                    > USED AT LINE 1383 IN MINT.asm
NESTING4:           27CE DEFINED AT LINE 1394 IN MINT.asm
                    > USED AT LINE 1389 IN MINT.asm
                    > USED AT LINE 1391 IN MINT.asm
CRLF:               27D0 DEFINED AT LINE 1399 IN MINT.asm
                    > USED AT LINE 145 IN MINT.asm
                    > USED AT LINE 1172 IN MINT.asm
SPACE:              27D9 DEFINED AT LINE 1405 IN MINT.asm
                    > USED AT LINE 608 IN MINT.asm
WRITECHAR:          27DD DEFINED AT LINE 1409 IN MINT.asm
                    > USED AT LINE 1242 IN MINT.asm
                    > USED AT LINE 1244 IN MINT.asm
                    > USED AT LINE 1250 IN MINT.asm
WRITECHAR1:         27DF DEFINED AT LINE 1412 IN MINT.asm
                    > USED AT LINE 1403 IN MINT.asm
                    > USED AT LINE 1407 IN MINT.asm
RPUSH:              27E2 DEFINED AT LINE 1415 IN MINT.asm
                    > USED AT LINE 212 IN MINT.asm
                    > USED AT LINE 588 IN MINT.asm
                    > USED AT LINE 1082 IN MINT.asm
                    > USED AT LINE 1095 IN MINT.asm
                    > USED AT LINE 1114 IN MINT.asm
                    > USED AT LINE 1284 IN MINT.asm
RPOP:               27ED DEFINED AT LINE 1422 IN MINT.asm
                    > USED AT LINE 626 IN MINT.asm
                    > USED AT LINE 656 IN MINT.asm
                    > USED AT LINE 777 IN MINT.asm
                    > USED AT LINE 1101 IN MINT.asm
STACK:              3880 DEFINED AT LINE 4 IN ram.asm
DSTACK:             3880 DEFINED AT LINE 5 IN ram.asm
                    > USED AT LINE 34 IN MINT.asm
                    > USED AT LINE 44 IN MINT.asm
                    > USED AT LINE 1056 IN MINT.asm
                    > USED AT LINE 1270 IN MINT.asm
                    > USED AT LINE 1273 IN MINT.asm
RSTACK:             3900 DEFINED AT LINE 8 IN ram.asm
                    > USED AT LINE 54 IN MINT.asm
TIB:                3900 DEFINED AT LINE 10 IN ram.asm
                    > USED AT LINE 96 IN MINT.asm
                    > USED AT LINE 128 IN MINT.asm
                    > USED AT LINE 137 IN MINT.asm
                    > USED AT LINE 154 IN MINT.asm
                    > USED AT LINE 1239 IN MINT.asm
                    > USED AT LINE 1254 IN MINT.asm
MINTVARS:           3A00 DEFINED AT LINE 13 IN ram.asm
                    > USED AT LINE 733 IN MINT.asm
                    > USED AT LINE 1122 IN MINT.asm
SYSVARS:            3A00 DEFINED AT LINE 14 IN ram.asm
                    > USED AT LINE 57 IN MINT.asm
                    > USED AT LINE 1122 IN MINT.asm
VS0:                3A00 DEFINED AT LINE 16 IN ram.asm
VBASE16:            3A02 DEFINED AT LINE 17 IN ram.asm
VTIBPTR:            3A04 DEFINED AT LINE 18 IN ram.asm
                    > USED AT LINE 72 IN MINT.asm
                    > USED AT LINE 81 IN MINT.asm
                    > USED AT LINE 90 IN MINT.asm
                    > USED AT LINE 153 IN MINT.asm
                    > USED AT LINE 1258 IN MINT.asm
VDEFS:              3A06 DEFINED AT LINE 19 IN ram.asm
                    > USED AT LINE 1102 IN MINT.asm
                    > USED AT LINE 1113 IN MINT.asm
                    > USED AT LINE 1117 IN MINT.asm
                    > USED AT LINE 1230 IN MINT.asm
                    > USED AT LINE 1297 IN MINT.asm
VEDITED:            3A08 DEFINED AT LINE 20 IN ram.asm
                    > USED AT LINE 1289 IN MINT.asm
VHEAPPTR:           3A0E DEFINED AT LINE 23 IN ram.asm
                    > USED AT LINE 192 IN MINT.asm
                    > USED AT LINE 201 IN MINT.asm
                    > USED AT LINE 780 IN MINT.asm
                    > USED AT LINE 1283 IN MINT.asm
                    > USED AT LINE 1315 IN MINT.asm
                    > USED AT LINE 1331 IN MINT.asm
VBYTEMODE:          3A36 DEFINED AT LINE 44 IN ram.asm
                    > USED AT LINE 194 IN MINT.asm
                    > USED AT LINE 783 IN MINT.asm
                    > USED AT LINE 1282 IN MINT.asm
TBPTR:              3A68 DEFINED AT LINE 46 IN ram.asm
RST08:              3A6A DEFINED AT LINE 48 IN ram.asm
RST10:              3A6C DEFINED AT LINE 49 IN ram.asm
RST18:              3A6E DEFINED AT LINE 50 IN ram.asm
RST20:              3A70 DEFINED AT LINE 51 IN ram.asm
RST28:              3A72 DEFINED AT LINE 52 IN ram.asm
RST30:              3A74 DEFINED AT LINE 53 IN ram.asm
BAUD:               3A76 DEFINED AT LINE 54 IN ram.asm
                    > USED AT LINE 31 IN BitBangSerial.asm
                    > USED AT LINE 45 IN BitBangSerial.asm
                    > USED AT LINE 94 IN BitBangSerial.asm
                    > USED AT LINE 105 IN BitBangSerial.asm
INTVEC:             3A78 DEFINED AT LINE 55 IN ram.asm
NMIVEC:             3A7A DEFINED AT LINE 56 IN ram.asm
GETCVEC:            3A7C DEFINED AT LINE 57 IN ram.asm
                    > USED AT LINE 31
                    > USED AT LINE 60
PUTCVEC:            3A7E DEFINED AT LINE 58 IN ram.asm
                    > USED AT LINE 33
                    > USED AT LINE 65
VARS:               3A80 DEFINED AT LINE 62 IN ram.asm
                    > USED AT LINE 733 IN MINT.asm
DEFS:               3AC0 DEFINED AT LINE 70 IN ram.asm
                    > USED AT LINE 47 IN MINT.asm
                    > USED AT LINE 61 IN MINT.asm
                    > USED AT LINE 1115 IN MINT.asm
HEAP:               3C00 DEFINED AT LINE 72 IN ram.asm
                    > USED AT LINE 51 IN MINT.asm
